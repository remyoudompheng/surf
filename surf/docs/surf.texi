\input texinfo
@c $Id$
@setfilename surf.info
@settitle surf
@setcontentsaftertitlepage

@include version.texi

@ifinfo
This file documents surf -- the visualization tool for real algebraic geometry.

Copyright (C) 1996-1997 Friedrich-Alexander-Universitaet Erlangen-Nuernberg,
1997-2001 Johannes Gutenberg-Universitaet Mainz.
@end ifinfo

@c title page
@c **********

@titlepage
@title surf
@subtitle visualization of real algebraic geometry
@author Stephan Endrass
@author Hans H@"ulf
@author R@"udiger @"Ortel
@author Ralf Schmitt
@author Kai Schneider
@author Johannes Beigel

@c copyright page
@page
@vskip 0pt plus 1filll
@multitable{Copyright @copyright{}} {1996--1997 Friedrich-Alexander-Universit@"at Erlangen-N@"urnberg,XX}
@item Copyright @copyright{}
@tab 1996--1997 Friedrich-Alexander-Universit@"at Erlangen-N@"urnberg,
@item
@tab 1997--2001 Johannes Gutenberg-Universit@"at Mainz.
@end multitable
@end titlepage


@c Top node
@c ********

@ifinfo

@node Top, Copying, , (dir)
@top surf

This document describes the usage of surf, the visualization tool for
real algebraic geometry.

This document applies to version @value{VERSION} of @command{surf}.

@menu
* Copying::
* Abstract::
* Overview::
* Introduction to surfs Command Language::
* Features::
* List Of All Reserved Words::
@end menu

@end ifinfo


@c Copying
@c *******

@node Copying, Abstract, top, top
@unnumbered Copying

Copyright @copyright{} 1996-1997 Friedrich-Alexander-Universitaet
Erlangen-Nuernberg, 1997-2001 Johannes Gutenberg-Universitaet Mainz.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

@c Abstract
@c ********

@node Abstract, Overview, Copying, top
@unnumbered Abstract

The aim was to have a tool to visualize some real algebraic geometry:
plane algebraic curves given as zero locus of a polynomial in two
variables, algebraic surfaces given as zero locus of a polynomial in
three variables, hyperplane sections of surfaces: algebraic space curves
given as zero locus of two polynomials in three variables: a polynomial
of arbitrary degree (the surface) and a linear polynomial (the
hyperplane), and lines on surfaces given by two points on a surface.

The algorithms should be stable enough not to be confused by
curve/surface singularities in codimension greater than one and the
degree of the surface or curve.  This has been achieved quite a bit. We
have drawn curves of degree up to 30 and surfaces of degree up to 20
successfully. However, there are examples of curves/surfaces of lower
degree where surf fails to produce perfect images. This happens
especially if the equation of the curve/surface is not reduced. Best
results are achieved using reduced equations. On the other hand, surf
displays the Fermat-curves accurately for degree up to 98.

@c Overview
@c ************

@node Overview, Acknowledgements, Abstract, top
@chapter Overview

@menu
* Acknowledgements::
* How to get surf::
* System Requirements::
* Starting surf::
* Scripting Language::
* Output::
* Sample Scripts::
* surf and make::
* Oddities and Bug Reports::
@end menu


@c Acknowledgements
@c ----------------

@node Acknowledgements, How to get surf, Overview, Overview
@section Acknowledgements

(by Stephan Endrass)

I thank Prof. W. Barth (University Erlangen) for (en)forcing me to start
this project. Hans H@"ulf, R@"udiger @"Ortel and Kai Schneider have
spent lots of time on coding parts of surf.

Some of the code has been copied from other places:

@itemize
@item
Writing SUN rasterfiles has been copied from Michael L. Mauldin's Fuzzy
PixMap (fbm) library version 1.2.
@item
Writing a TIFF file has been copied from John Cristy's Image Magick
version 3.0.
@item
The octree color reduction algorithm is copied from Ian Ashdown's
article <em>Octree Color Quantization</em> in the C/C++ Users Journal
Vol. 13, Number 3, pp. 31-43.
@end itemize

We thank all these people who made their code free so that we could use
it.

@c How to get surf
@c ---------------

@node How to get surf, System Requirements, Acknowledgements, Overview
@section Hot to get surf

surf is available via http/ftp at the surf home page
@url{http://surf.sourceforge.net}

@c System Requirements
@c -------------------

@node System Requirements, Starting surf, How to get surf, Overview
@section System Requirements

To compile surf, the following software is needed:

@itemize
@item
an ISO C++ compiler (GCC version 2.95 or higher should work, too),
@item
make
@item
GNU flex version 2.5 or higher (minor versions should
  work also, but lex does @emph{not} suffice),
@item
Berkeley yacc (GNU bison should work also),
@item
GNU MP (gmp) version 2 or later
@end itemize

@c Starting surf
@c -------------

@node Starting surf, Scripting Language, System Requirements, Overview
@section Starting surf

surf is started by typing @kbd{surf} on the command line.
Optional arguments are 

@option{--help} prints out the usage information.


@c Scripting Language
@c ------------------

@node Scripting Language, Output, Starting surf, Overview
@section Scripting Language

surf is designed to visualize algebraic curves and surfaces.  This can
be done either by writing scripts in surf's command language and
executing them interactively or from another program (for example make),
or by using surf's graphical user interface @command{gtksurf}.

@c Output
@c ------

@node Output, Sample Scripts, Scripting Language, Overview
@section Scripts

surf calculates both color and black & white images.

Color images can currently be stored in the following formats: Sun
Rasterfile, Portable Pixmap (PPM), JPEG, X Pixmap (XPM).  Additionally
one can choose a convenient colormap among: Netscape 216 color cube (8
bit), optimized by an octree algorithm (8 bit) and true color (24 bit).

Black & white images can be stored in the following formats:
Postscript (PS), Encapsulated Postscript (EPS), TIFF, X Bitmap (XBM),
Portable Bitmap (PBM).

@c Sample Scripts
@c --------------

@node Sample Scripts, surf and make, Output, Overview
@section Sample Scripts

You will find some sample scripts together with surf's
distribution. They are stored in the @file{examples} directory.

@c surf and make
@c -------------

@node surf and make, Oddities and Bug Reports, Sample Scripts, Overview
@section surf and make

surf can be invoked from @command{make}. This comes in quite handy when
visualising a series of curves/surfaces. Suppose there are script files
s1.pic, s2.pic, ... , sn.pic which create during execution images
s1.xpm, s2.xpm, ... , sn.xpm. If for example gif is the desired image
file format, an appropriate makefile might look like:

@example
    #!/bin/bash
    #
    SURF    = surf
    RM      = /bin/rm -f
    CONVERT = convert
    #
    OBJS    = s1.gif s2.gif .... sn.gif
    #
    .SUFFIXES: .pic .gif
    #
    .pic.gif:
    	$(SURF)    $<
    	$(CONVERT) $*.xpm $*.gif
    	$(RM)      $*.xpm
    #
    all: $(OBJS)
    #
    clean:
    	$(RM) *.gif
    #
    # end of makefile
@end example

Here convert is the Image Magick image format converter.

@c Oddities and Bug Reports
@c ------------------------

@node Oddities and Bug Reports, Introduction to surfs Command Language, surf and make, Overview
@section Oddities and Bug Reports

In case you find any bug, please use the excellent bug tracking system
on surf's project page at sourceforge:
@url{http://sourceforge.net/tracker/?group_id=3275}


@c Introduction to surf's Command Language
@c ***************************************

@node Introduction to surfs Command Language, Data Types, Oddities and Bug Reports, top
@chapter Introduction to surf's Command Language

@menu
* Data Types::
* Operators::
* Mathematical Functions::
* String Functions::
* Polynomial Functions::
* First Examples::
* Conditional Statements::
@end menu

@c Data Types
@c ----------

@node Data Types, Operators, Introduction to surfs Command Language, Introduction to surfs Command Language
@section Data Types

The language used in surf's scripts is quite simple.
It has got a (very restricted) C-like syntax and provides the four data types
@itemize
@item
@code{int}         (integer),
@item
@code{double} (double precision float value),
@item
@code{string} (any &dquot;&dquot;-quoted string) and
@item
@code{poly} (any polynomial in x, y and z).
@end itemize

So a valid declaration/initialisation looks like:
@itemize
@item
@code{int a=3;} or @code{int a; a=3;}
@item
@code{double b=3.3;} or @code{double b; b=3.3;}
@item
@code{string c="test.ppm";} or @code{string c; c="test.ppm";}
@item
@code{poly d=(x-3)^3-y^2+z;} or @code{poly d; d=(x-3)^3-y^2+z;}
@end itemize

There is no comma separator like in C. Declaring a name twice results in
an error. The scope of the name begins at the point of its declaration and
lasts until the end of the file. There is no method of undeclaring a name.

@c Operators
@c ---------

@node Operators, Mathematical Functions, Data Types, Introduction to surfs Command Language
@section Operators

The following arithmetic operators are implemented:

@multitable {operator} {greater or equal} {@{int,double,poly@}-@{int,double,poly@}}
@item operator @tab meaning @tab valid data types 

@item +   @tab binary plus    @tab @{int,double,poly@}+@{int,double,poly@}
@item +   @tab concatenation  @tab @{string@}+@{string@}
@item +   @tab unary plus     @tab +@{int,double,poly@}
@item -   @tab binary minus   @tab @{int,double,poly@}-@{int,double,poly@}
@item -   @tab unary minus    @tab -@{int,double,poly@}
@item *   @tab multiplication @tab @{int,double,poly@}*@{int,double,poly@}
@item /   @tab division       @tab @{int,double,poly@}/@{int,double@}
@item %   @tab remainder      @tab @{int@}%@{int@}
@item ^   @tab power          @tab @{int,double@}^@{int,double@}@*
                                   @{poly@}^@{int@}
@item ( ) @tab brackets       @tab (@{int,double,poly@})
@item =   @tab assignment     @tab @{poly@}=@{int,double,poly@}@*
                                   @{double@}=@{int,double@}@*
                                   @{int@}=@{int@}@*
                                   @{string@}=@{string@}
@item ==  @tab equal          @tab @{int,double@}==@{int,double@}
@item !=  @tab not equal      @tab @{int,double@}!=@{int,double@}
@item <   @tab smaller than   @tab @{int,double@}<@{int,double@}
@item <=  @tab smaller or equal @tab @{int,double@}<=@{int,double@}
@item >   @tab greater than   @tab @{int,double@}>@{int,double@}
@item >=  @tab greater or equal @tab @{int,double@}>=@{int,double@}
@end multitable

The precedence of operators copied from C.


@c Mathematical Functions
@c ----------------------

@node Mathematical Functions, String Functions, Operators, Introduction to surfs Command Language
@section Mathematical Functions

There are some built-in math functions:

@multitable {function} {arcus tangens} {@code{pow(@{double@},@{int,double@})}} {returns}
@item function      @tab meaning       @tab valid arguments               @tab returns
@item @code{sqrt}   @tab square root   @tab @code{sqrt(@{int,double@})}   @tab @code{double}
@item @code{pow}    @tab power         @tab @code{pow(@{int@},@{int,double@})} @*
                                    @code{pow(@{double@},@{int,double@})} @tab @code{double}
@item @code{sin}    @tab sine          @tab @code{sin(@{int,double@})}    @tab @code{double}
@item @code{cos}    @tab cosine        @tab @code{cos(@{int,double@})}    @tab @code{double}
@item @code{arcsin} @tab arcus sine    @tab @code{arcsin(@{int,double@})} @tab @code{double}
@item @code{arccos} @tab arcus cosine  @tab @code{arccos(@{int,double@})} @tab @code{double}
@item @code{tan}    @tab tangens       @tab @code{tan(@{int,double@})}    @tab @code{double}
@item @code{arctan} @tab arcus tangens @tab @code{arctan(@{int,double@})} @tab @code{double}
@end multitable

They take @code{int} and @code{double} as argument.

@c String Functions
@c ----------------

@node String Functions, Polynomial Functions, Mathematical Functions, Introduction to surfs Command Language
@section String Functions

There are also two functions returning strings:

@multitable {@code{istostrn}} {@code{itostrn(@{int@},@{int@})}} {@code{string} of spec. length}
@item function       @tab valid arguments                 @tab returns
@item @code{itostr}  @tab @code{itostr(@{int@})}          @tab @code{string}
@item @code{itostrn} @tab @code{itostrn(@{int@},@{int@})} @tab @code{string} of spec. length
@end multitable

@code{itostr()} converts its argument to a @code{string} without blanks. For example
@code{itostr(31)} returns @code{"31"}.
@code{itostrn()} allows to specify the length of the @code{string}.
For example:
@itemize
@item
@code{itostrn(3, 88)} returns @code{"088"}
@item
@code{itostrn(4, 88)} returns @code{"0088"}
@end itemize


@c Polynomial Functions
@c --------------------

@node Polynomial Functions, First Examples, String Functions, Introduction to surfs Command Language
@section Polynomial Functions

Some functions work on polynomials:

@multitable {function} {Hesse surface} {@code{rotate(@{poly@},@{double@},@{xAxis,yAxis,zAxis@})}} {returns}
@item function      @tab meaning       @tab valid arguments                  @tab returns
@item @code{deg}    @tab degree        @tab @code{deg(@{poly@})}             @tab @code{int}
@item @code{len}    @tab length        @tab @code{len(@{poly@})}             @tab @code{int}
@item @code{diff}   @tab derivative    @tab @code{diff(@{poly@},@{x,y,z@})}  @tab @code{poly}
@item @code{rotate} @tab rotation      @tab @code{rotate(@{poly@},@{double@},@{xAxis,yAxis,zAxis@})} @tab @code{poly}
@item @code{hesse}  @tab Hesse surface @tab @code{hesse(@{poly@})}           @tab @code{poly}
@end multitable

This enables you to work out arbitrary polynomials. 


@c First Exapmles
@c --------------

@node First Examples, Conditional Statements, Polynomial Functions, Introduction to surfs Command Language
@section First Examples

Values can be passed to surf by setting global variables. The most
important two global variables are @code{curve} and @code{surface},
which should be set to the polynomial whose zero set should be
visualized. So the shortest effective script contains only three lines,
for example:
@itemize
@item
1st example: Draw the Newton knot.
@example
        curve = y^2 - x^2*(x + 1);
        draw_curve;
        filename = "newton.ppm";
        save_color_image;
@end example
@item
2nd example: Draw a sphere.
@example
        surface = x^2 + y^2 + z^2 - 80;
        draw_surface;
        filename = "sphere.ppm";
        save_color_image;
@end example
@end itemize

@c Conditional Statements
@c ----------------------

@node Conditional Statements, Features, First Examples, Introduction to surfs Command Language
@section Conditional Statements

There are no @code{for} and no @code{while} statements.
There is only the crude
@example
    if(INTEGER-EXPRESSION) goto LABEL;
@end example
which you might remember from your early BASIC sessions.

Here @code{INTEGER-EXPRESSION} can be arbitrary complicated as long as it
results in an integer. @code{LABEL} is something like @code{NAME}
which has occurred before as @code{NAME:}. Consider the example
@example
    int i = 0;
    loop:
        surface = x^2 + y^2 + z^2 - (i + 1.0)/2.0;
        clear_screen;
        draw_surface;
        filename = "sphere" + itostrn(2, i) + ".xpm";
        save_color_image;
        i = i + 1;
    if(i < 50) goto loop;
@end example
which obviously draws fifty spheres of increasing radius 
and saves them into the X Pixmap files:
@file{sphere00.xpm}, @dots{} @file{sphere49.xpm}.

@c Features
@c ********

@node Features, Plane Curves, Conditional Statements, top
@chapter Features

In this section most features of surf are explained.  For a complete
reference to the command language, have a look at
@ref{List Of All Reserved Words}.

@menu
* Plane Curves::
* Surfaces::
* Hyperplane Sections::
* Multiple Curves/Surfaces::
* Graphs and Isolines::
* Antialiasing Surfaces::
* Animations::
* Stereo Pictures::
* Black & White Images::
* Algorithms::
* Image Formats::
@end menu


@c Plane Curves
@c ------------

@node Plane Curves, Surfaces, Features, Features
@section Plane Curves

To draw a plane curve, set the global variable @code{curve} to the
polynomial describing the curve and call the @code{draw_curve}
command. To see the result, save the image by setting the
@code{filename} variable and calling @code{save_color_image}.
Example script:
@example
        curve = x^2 + y^2 - 1;
        draw_curve;
        filename = "circle.xpm";
        save_color_image;
@end example

By default the curve is drawn inside the rectangle
@ifnottex
@math{-10.0 <= x, y <= 10.0}
@end ifnottex
@tex
$-10.0 \le x, y \le 10.0 $
@end tex
and is clipped at a circle with radius 10.0.  The x-axis is
horizontal pointing to the right, the y-axis is vertical and points
upwards. By default the image size is 200x200 pixels.  The image size
can be altered by setting the variables @code{width} and @code{height}.

A different origin can be specified by setting
@code{origin_x} and @code{origin_y}.
A rotation with center at @math{(0, 0)} can be specified by setting
@code{rot_z}. The curve may be scaled by setting
@code{scale_x} and @code{scale_y}.

The width of the curve is determined by the variable @code{curve_width}
and the gamma value by @code{curve_gamma} respectively.  A high gamma
value sharpens the curve, whereas a low value blurs the curve.

The clipping area can be specified by setting @code{clip}. For a curve
the only reasonable values are @code{sphere} or to @code{none}. When
choosing @code{sphere} you can adjust the variable @code{radius}.

An arbitrary color can be given to the curve by setting
@code{curve_red}, @code{curve_green} and @code{curve_blue} to
appropriate values between 0 and 255.

@c Surfaces
@c --------

@node Surfaces, Hyperplane Sections, Plane Curves, Features
@section Surfaces

To draw a plane curve, set the global variable @code{curve} to the
polynomial describing the curve and call the @code{draw_curve}
command. To see the result, save the image by setting the
@code{filename} variable and calling @code{save_color_image}. Example
script:
@example
        surface = x^2 + y^2 + z^2 - 4;
        draw_surface;
        filename = "sphere.jpg";
        save_color_image;
@end example

By default, the surface
is calculated inside the cube
@ifnottex
@math{-10.0 <= x, y, z <= 10.0}
@end ifnottex
@tex
$-10.0 \le x, y, z \le 10.0$
@end tex
and clipped at a sphere of radius 10.0.

The x-axis is horizontal pointing to the right, the y-axis is vertical
and points upwards. The z-axis points to you. The spectator is located
at @math{(0, 0, 25)} by default.

A different origin may be specified by setting @code{origin_x},
@code{origin_y} and @code{origin_z}.  To rotate the surface one can set
@code{rot_x} about x-axis @code{rot_y} and @code{rot_z} to appropriate
values. Rotation is performed on the following order: y-axis, x-axis,
z-axis.

To scale the surface set @code{scale_x}, @code{scale_y} and
@code{scale_z} to desired values.

It is also possible to switch from central perspective to parallel
perspective by setting @code{perspective} to @code{central} or
@code{parallel} respectively.

Illumination and color can be altered, too.  The direction of the normal
vector given by the gradient of the surface equation defines one side of
the surface which is regarded as outside. You can specify a color for
this side by setting @code{surface_red}, @code{surface_green} and
@code{surface_blue}. The other side of the surface (inside) can be given
a different color by specifying @code{inside_red}, @code{inside_green}
and @code{inside_blue}.

Currently only the Phong illumination model is implemented.
Therefore the intensity of the surface in one point consists of
four components which are calculated separately:
@itemize
@item
ambient light,
@item
diffuse light,
@item
reflected light and
@item transmitted light.
@end itemize

Ambient light is a constant which represents the light a point on the
surface receives from the whole environment (the sky, the floor, the
lawn @dots{})  but not from the light sources.

Diffuse light is the light the point receives from the light sources and
which is reflected equally in every possible direction. The amount of
diffuse light is independent of the spectator position, it is
proportional to the cosine of the angle between the normal vector and
the vector from the point to the light source.

Reflected light is the light from the light sources which is reflected
specular from the surface point. Its amount is proportional to a power
of the cosine of the angle between the vector from the point to the
spectator and the specular reflection vector from the light source. If a
high power of the cosine is taken, the surface will appear shiny,
whereas a low power of the cosine lets the surface look rough.  Therfore
the variable controlling this power is named @code{smoothness}.

Transmitted light comes in if a surface is transparent. A variable
called @code{transparence} specifies the percentage of light which
passes through the surface. Algebraic surfaces are infinitesimally
thin. However our eye is not used to such objects, so we pretend that
our surfaces have a constant @code{thickness}. Specifying a positive
@code{thickness} for a transparent surface results in a loss of
transparency in the places where the surface normal does not point to
the spectator.

These four light components are added with weights @code{ambient},
@code{diffuse}, @code{reflected} and @code{transmitted}.

The number of light sources is limited to nine. For every light source,
the position, the color and the intensity can be specified. See the next
chapter for a complete listing of these variables.

The shape of the clipping area is determined by the variable
@code{clip}. The center is specified via @code{center_x},
@code{center_y}, @code{center_z} and the radius via @code{radius}.
Additionally a front and a back clipping plane may be specified by
setting @code{clip_front} and @code{clip_back}.

@c Hyperplane Sections
@c -------------------

@node Hyperplane Sections, Multiple Curves/Surfaces, Surfaces, Features
@section Hyperplane Sections

To draw one or more hyperplane sections of an algebraic surface, just
specify the hyperplane by setting the global variable @code{plane} to
its equation.

The section is drawn when the command @code{cut_with_plane} is interpreted.
For example:
@example
    rot_x = 0.3; // a nice rotation
    rot_y = 0.2;

    // draw the steiner roman surface:
    surface = x^2*y^2  +y^2*z^2 + z^2*x^2 - 16*x*y*z;
    clear_screen;
    draw_surface;

    // draw a green hyperplane section
    curve_red = 0;
    curve_green = 255;
    curve_blue = 0;
    curve_width = 5;
    curve_gamma = 1.2;
    plane = x + y + z;
    cut_with_plane;

    // draw another one
    plane = x + y + z + 4.0;
    cut_with_plane;

    // save image:
    filename = "hyperplanesections.jpg";
    save_color_image;
@end example

The color of the hyperplane section can be set by specifying
@code{curve_red}, @code{curve_green} and @code{curve_blue}.  The width
of the section is altered by setting @code{curve_width} to any suitable
value. A high value of @code{curve_gamma} (eg. 10.0) makes the curve
look very pixelized, whereas a small value (eg. 1.0) makes the section
look blurred.

@c Multiple Curves/Surfaces
@c ------------------------

@node Multiple Curves/Surfaces, Graphs and Isolines, Hyperplane Sections, Features
@section Multiple Curves/Surfaces

Multiple curves can be drawn in script files just by @emph{not} clearing
the screen. This works fine for plane curves.  Just consider the
following example:
@example
    // draw a cubic
    curve = y^2 - x^2*(x - 1);
    draw_curve;

    // draw y-axis
    curve = x;
    draw_curve;
    
    // draw x-axis:
    curve = y;
    draw_curve;

    // save image:
    filename = "cubic.xpm";
    save_color_image;
@end example

Note that every curve will be drawn just over all curves that have been
drawn so far.

Multiple surfaces can be drawn by specifying up to nine surfaces in the
variables @code{surface}, @code{surface2}, @dots{},
@code{surface9}. Additionally it is possible to draw on every surface
any number of hyperplane sections.

@example
    rot_x = 0.69; // a nice rotation
    rot_y = 0.35;
    illumination = ambient_light +  // specify illumination model
                   diffuse_light +
                   reflected_light +
                   transmitted_light;
    transparence = 35;  // set transparence for surface no 1
    transparence2 = 35; // set transparence for surface no 2

    // first surface: a sphere
    surface = x^2 + y^2 + z^2 - 30;  

    // second surface: a red steiner surface
    surface2_red = 255;              
    surface2_green = 0;
    surface2_blue = 0;
    surface2 = x^2*y^2 + x^2*z^2 + y^2*z^2 - 16*x*y*z;

    draw_surface; // draw both surfaces

    // draw a green hyperplane section...
    curve_width = 5;
    curve_red = 0;
    curve_green = 255;
    curve_blue = 0;
    plane = x + y + z - 6.0;
    surf_nr = 1;           // ...on the sphere
    cut_with_plane;

    // draw a turquoise hyperplane section...
    curve_red = 0;
    curve_green = 255;
    curve_blue = 255;
    plane = x + y + z +4.0;                 
    surf_nr = 2;           // ...on the steiner surface
    cut_with_plane;

    // save the image
    filename = "multisurfs.jpg";
    save_color_image;
@end example

@c Graphs and Isolines
@c -------------------

@node Graphs and Isolines, Antialiasing Surfaces, Multiple Curves/Surfaces, Features
@section Graphs and Isolines

Given a polynomial function @math{f(x, y)} and a set of levels
@math{z1}, @dots{}, @math{zn}, surf can visualize the graph @math{z =
f(x, y)} and all isolines for the levels @math{z1}, @dots{}, @math{zn}
as follows:
@example
    rot_x = -0.8;
    poly f = x^2 + y^2; // graph of (x,y) -> x^2 + y^2
    surface = z - f;
    draw_surface;      // draw the graph

    curve_width = 3;   // width of isolines
    int i = 1;
    loop:
        plane = z - i;
        cut_with_plane; // draw isoline f(x,y) = i
        i = i + 1;
    if(i < 10) goto loop;

    // save image
    filename = "isolines.jpg";
    save_color_image;
@end example

If however your function @math{f} is not polynomial, try to expand
calculate its Taylor series. Since the new root algorithms work fine
with polynomials of degree up to 30, you might approximate @math{f} by
its Taylor series. If your function is piecewise defined, better use
another program.

@c Antialiasing Surfaces
@c ---------------------

@node Antialiasing Surfaces, Animations, Graphs and Isolines, Features
@section Antialiasing Surfaces

Especially in animations aliasing is very disturbing. Therefore if
@code{antialiasing} is set to a value
@ifnottex
@math{n >= 1}
@end ifnottex
@tex
$n \ge 1$
@end tex
then in a second pass all pixels differing by a value of at least
@code{antialiasing_threshold} from one of their neighbours are
refined. Exactly
@ifnottex
@math{n^2+1}
@end ifnottex
@tex
$n^2 + 1$
@end tex
intensity values are calculated. In most
cases an antialiasing level of 4 will remove aliasing.

@c Animations
@c ----------

@node Animations, Stereo Pictures, Antialiasing Surfaces, Features
@section Animations

You can calculate a series of images with surf and convert this
series of images to the movie format of your choice.
@example
    // --------------------------
    // the 4-nodal cubic rotating
    // --------------------------
    
    width = 200;  // set image size
    height = 200;
    
    double sf = 0.3;
    scale_x = sf; // set scaling
    scale_y = sf;
    scale_z = sf;

    double pi = 2*arccos(0); // define some constants
    double w2 = sqrt(2);
    
    // define tetrahedral coordinates
    poly p = 1 - z - w2*x;
    poly q = 1 - z + w2*x;
    poly r = 1 + z + w2*y;
    poly s = 1 + z -w2*y;

    // the cubic:
    poly cubic = 4*(p^3 + q^3 + r^3 + s^3) - (p + q + r + s)^3;

    int i = 0;
    loop:
        surface = rotate(cubic, 2*pi/100*i, zAxis); // rotate the cubic
        clear_screen;
        draw_surface; // draw the cubic
        filename = "cubic" + itostrn(3, i) + ".ras";
        save_color_image; // save the image
        i = i + 1;
    if(i < 100) goto loop; // repeat 100 times
@end example
Here some 100 Sun rasterfiles are created.  Afterwards you could use a
tool to convert these single images to a movie. For example with the
@command{convert} program from the ImageMagick suite you could type
@kbd{convert -delay 5 cubic*.ras cubic.gif} to create a GIF animation.


@c Stereo Pictures
@c ---------------

@node Stereo Pictures, Black & White Images, Animations, Features
@section Stereo Pictures

Have you ever watched one of those films with that red and green
glasses? surf tries to accomplish exactly this effect when you set
@code{stereo_eye} to a value greater than zero.

The following situation is simulated: The spectator is located at
@math{(0,0, spectator z)} and the distance between his eyes is
@code{stereo_eye}. The surface will appear at the z-coordinate
@code{stereo_z}.  Furthermore it is possible to adjust to specific
red-green or red-blue glasses by setting @code{stereo_red} (left eye),
@code{stereo_green} and @code{stereo_blue} (right eye). In particular it
is assumed that the right eye wears the red glass.

@c Black & White Images
@c --------------------

@node Black & White Images, Dithering with Blue Noise, Stereo Pictures, Features
@section Black & White Images

If a color image of a surface/curve has been calculated, this image can
be mapped to a black and white image by calling one of the commands
@code{dither_surface} or @code{dither_curve}.  The second one is just
designed for dithering curves.

The appearance of the black and white image can be altered/adjusted in
several ways.  Since the mapping itself is done by dithering, the
dithering algorithm can be specified. Currently available are seven
algorithms coming in three groups:

@menu
* Dithering with Blue Noise::
* Dithering with Ordered Dither::
* Hybrid Methods::
* The Black & White Problem::
@end menu

@c Dithering with Blue Noise

@node Dithering with Blue Noise, Dithering with Ordered Dither, Black & White Images, Black & White Images
@subsection Dithering with Blue Noise

@itemize
@item Floyd-Steinberg filter
@item Jarvis, Judis and Ninke filter
@item Stucki filter
@end itemize

All three filters are based on the same idea of error
distribution. Floyd Steinberg is the simplest one, whereas Stucki
differs from Jarvis only by its weights. They tend to produce disturbing
patterns if they process large areas of intensity near 0.5. Therefore
one can let them proceed in a serpentine fashion, which reduces the
patterns. Nearly all patterns disappear if the weights are disturbed
randomly. The algorithms are best for use with low resolution printers,
typically 300 dpi. Some (most?) 600 dpi laser printers do not like these
algorithms, since they do not like isolated pixels.

@c Dithering with Ordered Dither

@node Dithering with Ordered Dither, Hybrid Methods, Dithering with Blue Noise, Black & White Images
@subsection Dithering with Ordered Dither

@itemize
@item Clustered dot ordered dither
@item Dispersed dot ordered dither
@end itemize
The clustered dot ordered dither is a fast method and produces
satisfying results in combination with high resolution printers (600 dpi
and more). The second algorithm is for use with low resolution
printers. Both perform no error distribution. Depending on the printer
resolution and the number of emulated gray levels, one can choose the
pattern size:
@itemize
@item 4 x 4 pixels: 16 gray levels,
@item 8 x 8 pixels: 64 gray levels or
@item 16 x 16 pixels: 256 gray levels.
@end itemize

@c Hybrid Methods

@node Hybrid Methods, The Black & White Problem, Dithering with Ordered Dither, Black & White Images
@subsection Hybrid Methods

@itemize
@item Knuth's dot diffusion
@item Knuth's smooth dot diffusion
@end itemize
Both algorithms combine clustered dot ordered dither and error
distribution. Depending on the printer resolution on can choose the
number of barons in a 8x8 matrix to be
@itemize
@item 1 for resolutions of 1200 dpi or above or
@item 2 for resolutions of 600 dpi or above.
@end itemize
The barons are the bad guys in a matrix which get all the error left
over from the good guys.

@c The Black & White Problem

@node The Black & White Problem, Algorithms, Hybrid Methods, Black & White Images
@subsection The Black & White Problem

The surfaces on black and white images often don't look very impressive;
often it is hard to detect the edges of a surface. An algorithm called
enhancing the edges avoids this drawback. This algorithm takes a value
@code{alpha} in @math{[0, 1]} as input.  Best results are achieved with
@code{alpha} around 0.9.

The intensity of the background on the black and white image can be
specified by altering the value @code{background} to any value in
@math{[0, 1]}. Here 0 is black whereas 1 means white.

If @code{tone_scale_adjustment} is set to @code{yes}, intensity values
between 0 and 0.1 are mapped to 0, values between 0.1 and 0.9 linearly
to @math{[0, 1]} and values between 0.9 and 1 to 1. This is used to
enhance the contrast of an image. Additionally, @code{gamma_correction}
can be set to @code{yes} to correct the linearity of an output device.

By specifying @code{pixel_size} one can correct the printer pixel size:
A value of 50 means that the radius of a pixel is exactly half the
distance between two neighbouring pixels. A value of 100 says that the
radius of a pixel is exactly the distance between two neighbouring
pixels.

@c Algorithms
@c ----------

@node Algorithms, Image Formats, The Black & White Problem, Features
@section Algorithms

The heart of surf is an algorithm which determines all roots of a
polynomial in one variable. Currently you can choose between six
methods for the @code{root_finder} variable:
@itemize
@item @code{d_chain_bisection}
@item @code{d_chain_regula_falsi}
@item @code{d_chain_pegasus}
@item @code{d_chain_anderson_bjoerck}
@item @code{d_chain_newton}
@item @code{bezier_all_roots}
@end itemize
The first five methods use a
chain of derivatives to determine intervals where the polynomial has
exactly one root. They differ by the iteration method which is used to
find the roots in these intervals. Some of the iteration methods were
just implemented out of academic interest. However, they all work. The
last method uses Rockwoods all roots algorithm: the polynomial is
converted into a bezier function and the roots of the bezier function
are approximated by the roots of the control polygon.

For curves/surfaces of degree less than ten, all methods work.  When the
degree gets higher, best results are achieved by the bisection, the
Newton and the bezier all roots method. At last, for a degree higher
than 30 only the bisection methods seems to work (up to degree 50). If a
curve has multiple components, the bisection and the Newton method tend
to produce the best results.

Moreover it is possible to specify a numerical precision @code{epsilon}
which is used in all root finders.  Additionally the maximal number of
@code{iterations} of the iteration methods can be specified.

@c Image Formats
@c -------------

@node Image Formats, List Of All Reserved Words, Algorithms, Features
@section Image Formats

surf can store color images in one of several file formats. By setting
@code{color_file_format} you can choose between:
@multitable {@code{jpeg}} {Sun Rasterfiles (suffix: ".ras")}
@item @code{jpeg} @tab JPEG
@item @code{ppm}  @tab Portable Pixmap
@item @code{sun}  @tab Sun Rasterfiles (suffix: ".ras")
@item @code{xpm}  @tab X Pixmap
@end multitable
Additionally the value of @code{color_file_colormap} can be chosen
among:
@multitable {@code{Optimized}} {optimized by an octree algorithm (8 bit) and}
@item @code{Netscape}  @tab Netscape 216 color cube (8 bit)
@item @code{Optimized} @tab optimized by an octree algorithm (8 bit)
@item @code{TrueColor} @tab true color (24 bit)
@end multitable
The first colormap is just the 6x6x6 colormap Netscape uses.  The second
one results from an octree algorithm which chooses the most used 216
colors among all colors of the image. @code{color_file_colormap} is only
evaluated if it makes sense with the chosen @code{color_file_format}.
The quality of JPEG images can be adjusted by setting
@code{jpeg_quality} to an appropriate value between 0 and 100.

surf can store black and white images these formats (set the variable
@code{dither_file_format}):
@multitable {@code{postscript}} {Encapsulated Postscript}
@item @code{eps}        @tab Encapsulated Postscript
@item @code{pbm}        @tab Portable Bitmap
@item @code{postscript} @tab Postscript
@item @code{tiff}       @tab TIFF
@item @code{xbm}        @tab X Bitmap
@end multitable
For postscript and encapsulated postscript the resolution may be
specified (by setting @code{resolution}) among:
@code{res_75dpi}, @code{res_100dpi}, @code{res_150dpi}, @code{res_300dpi},
@code{res_600dpi} and @code{res_1200dpi}.

When using postscript, the image will (regardless its size) appear
centered on the page (which is assumed to be A4).


@c List Of All Reserved Words
@c **************************

@node List Of All Reserved Words, Main Variables, Image Formats, top
@chapter List Of All Reserved Words

A reserved word in surf's language is either a command or a global
variable. A command is invoked mostly without parameters. Global
variables are either constant or may be altered.

@menu
* Main Variables::
* Drawing Commands::
* Positioning::
* Saving Images::
* Image Variables::
* Lighting Variables::
* Clipping::
@end menu


@c Main Variables
@c --------------

@node Main Variables, Drawing Commands, List Of All Reserved Words, List Of All Reserved Words
@section Main Variables

@multitable {Reserved Word} {@code{string}} {@{64, @dots{}, 3000@}} {Default} {height of surface image}
@item Reserved Word @tab Type @tab Range @tab Default @tab Description
@item @code{curve}    @tab @code{poly} @tab --- @tab @code{0} @tab polynomial of curve
@item @code{surface}  @tab @code{poly} @tab --- @tab @code{0} @tab polynomial of surface
@item @code{surface2} @tab @code{poly} @tab --- @tab @code{0} @tab polynomial of surface2
@item @dots{}         @tab @dots{}  @tab @dots{} @tab @dots{} @tab @dots{}
@item @code{surface9} @tab @code{poly} @tab --- @tab @code{0} @tab polynomial of surface9
@item @code{plane}    @tab @code{poly} @tab linear @tab @code{0} @tab equation of hyperplane
@item @code{width}    @tab @code{int}  @tab @{@code{64}, ..., @code{3000}@} @tab @code{200} @tab width of image
@item @code{height}   @tab @code{int}  @tab @{@code{64}, ..., @code{3000}@} @tab @code{200} @tab height of image
@item @code{surf_nr}  @tab @code{int}  @tab @{@code{1},..., @code{9}@} @tab @code{1} @tab surface which is used for @code{cut_with_plane}
@end multitable

@c Drawing Commands
@c ----------------
@node Drawing Commands, Positioning, Main Variables, List Of All Reserved Words
@section Drawing Commands

@multitable @columnfractions 0.2 0.8
@item Reserved Word: @tab Description:
@item @code{clear_screen}        @tab erase the image
@item @code{draw_curve}          @tab draw the curve defined by the global
                                      polynomial @code{curve}
@item @code{draw_surface}        @tab draw the surfaces defined by the global
                                      polynomials @code{surface}, @code{surface2},
                                      @dots{}, @code{surface9}
@item @code{cut_with_plane}      @tab draw the hyperplane section defined
                                      defined by the linear polynomial @code{plane}
@item @code{dither_surface}      @tab convert color image to a dithered
                                      black and white image
@item @code{dither_curve}        @tab convert color image to a dithered
                                      black and white image (for curves only)
@end multitable

@c Positioning
@c -----------

@node Positioning, Saving Images, Drawing Commands, List Of All Reserved Words
@section Positioning

@multitable {Reserved Word} {@code{double}} {]@code{-9999}, @code{9999}[} {@code{translate}} {spectator distance from origin}
@item Reserved Word @tab Type @tab Range @tab Default @tab Description
@item @code{origin_x}    @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{0} @tab x position of origin
@item @code{origin_y}    @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{0} @tab y position of origin
@item @code{origin_z}    @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{0} @tab z position of origin
@item @code{spec_z}      @tab @code{double} @tab ]@code{0}, @code{9999}[     @tab @code{100} @tab spectator distance from origin
@item @code{rot_x}       @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{0} @tab rotation angle of surface about the x-axis
@item @code{rot_y}       @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{0} @tab rotation angle of surface about the y-axis
@item @code{rot_z}       @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{0} @tab rotation angle of surface about the z-axis
@item @code{scale_x}     @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{1} @tab ratio surface is scaled in direction of the x-axis
@item @code{scale_y}     @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{1} @tab ratio surface is scaled in direction of the y-axis
@item @code{scale_z}     @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{1} @tab ratio surface is scaled in direction of the z-axis
@item @code{perspective} @tab @code{int}    @tab @{@code{parallel}, @code{central}@} @tab @code{parallel} @tab perspective to use
@item @code{first}       @tab @code{int}    @tab @{@code{translate}, @code{rotate}, @code{scale}@} @tab @code{translate} @tab first performed action
@item @code{second}      @tab @code{int}    @tab @{@code{translate}, @code{rotate}, @code{scale}@} @tab @code{rotate}  @tab second performed action
@item @code{third}       @tab @code{int}    @tab @{@code{translate}, @code{rotate}, @code{scale}@} @tab @code{scale} @tab third performed action
@end multitable

@c Saving Images
@c -------------

@node Saving Images, Image Variables, Positioning, List Of All Reserved Words
@section Saving Images

@multitable {@code{save_dithered_image}} {@code{string}} {@code{postscript,}} {@code{auto}} {save color image in file defined}
@item Reserved Word              @tab Type          @tab Range @tab Def.     @tab Description
@item @code{save_color_image}    @tab cmd.          @tab ---   @tab ---       @tab save color image in file defined by the global string @code{filename}
@item @code{save_dithered_image} @tab cmd.          @tab ---   @tab ---       @tab save dithered black and white image in file defined by the global string @code{filename}
@item @code{filename}            @tab @code{string} @tab any   @tab @code{""} @tab filename used in @code{save_color_image} and @code{save_dithered_image}
@item @code{color_file_format}   @tab @code{int}    @tab @{@code{auto},@* @code{jpeg},@* @code{ppm},@* @code{sun},@* @code{xpm}@} @tab @code{auto} @tab file format used in @code{save_color_image}
@item @code{dither_file_format}  @tab @code{int}    @tab @{@code{auto},@* @code{eps},@* @code{pbm},@* @code{postscript},@* @code{tiff},@* @code{xbm}@} @tab @code{auto} @tab file format used in @code{save_dithered_image}
@end multitable

@c Image Variables
@c ---------------

@node Image Variables, Lighting Variables, Saving Images, List Of All Reserved Words
@section Image Variables

@multitable {@code{antialiasing_threshold}} {@code{string}} {@code{postscript,}} {@code{auto}} {save color image in file defined}
@item Reserved Word                 @tab Type          @tab Range @tab Def.     @tab Description
@item @code{dither_colors}          @tab @code{int}    @tab @{@code{yes}, @code{no}@} @tab @code{yes} @tab color dithering
@item @code{dither_steps}           @tab @code{double} @tab [@code{5}, @dots{}...,@code{255}] @tab @code{20.0} @tab steps of dithering
@item @code{normalize}              @tab @code{int}    @tab @{@code{yes}, @code{no}@} @tab @code{no} @tab normalize image
@item @code{normalize_factor}       @tab @code{double} @tab ]@code{0}, @dots{}, @code{5}] @tab @code{1.0} @tab multiply with
@item @code{antialiasing}           @tab @code{int}    @tab @{@code{1}, @dots{}, @code{8}@} @tab @code{1} @tab level of antialiasing
@item @code{antialiasing_threshold} @tab @code{double} @tab ]@code{0}, @code{1}[ @tab @code{0.1} @tab threshold
@item @code{antialiasing_radius}    @tab @code{double} @tab [@code{0.5}, @code{2}] @tab @code{2.0} @tab radius 
@item @code{depth_cueing}           @tab @code{int}    @tab @{@code{yes}, @code{no}@} @tab @code{no} @tab use depth cueing
@item @code{depth_value}            @tab @code{double} @tab [@code{-1000}, @code{10}[ @tab @code{-14.0} @tab depth of mist
@item @code{stereo_eye}             @tab @code{double} @tab [@code{-100}, @code{100}] @tab @code{0.0} @tab eye distance
@item @code{stereo_z}               @tab @code{double} @tab [@code{-30}, @code{30}] @tab @code{5.0} @tab distance from screen
@item @code{stereo_red}             @tab @code{double} @tab [@code{0}, @code{1}] @tab @code{1.0} @tab left eye red
@item @code{stereo_green}           @tab @code{double} @tab [@code{0}, @code{1}] @tab @code{0.7} @tab right eye green
@item @code{stereo_blue}            @tab @code{double} @tab [@code{0}, @code{1}] @tab @code{0.0} @tab right eye blue
@end multitable

@c Lighting Variables
@c ------------------

@node Lighting Variables, Clipping, Image Variables, List Of All Reserved Words
@section Lighting Variables

@multitable {@code{surface9_green}} {@code{double}} {@code{transmitted_light}} {@code{amb... +}} {volume of 9th light source}
@item Reserved Word          @tab Type          @tab Range @tab Def.     @tab Description
@item @code{illumination}    @tab @code{int}    @tab any sum of@* @code{ambient_light}, @code{diffuse_light}, @code{reflected_light} and@* @code{transmitted_light} @tab @code{amb.. + diff.. + refl..} @tab illumination model
@item @code{surface_red}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{123} @tab color of @code{surface}
@item @code{surface_green}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{104} @tab
@item @code{surface_blue}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{238} @tab
@item @code{inside_red}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{230} @tab inside color of @code{surface}
@item @code{inside_green}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{180} @tab
@item @code{inside_blue}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{30}  @tab
@item @code{surface2_red}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{123} @tab color of @code{surface2}
@item @code{surface2_green}  @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{104} @tab
@item @code{surface2_blue}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{208} @tab
@item @code{inside2_red}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{230} @tab inside color of @code{surface2}
@item @code{inside2_green}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{180} @tab
@item @code{inside2_blue}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{30}  @tab
@item @dots{}                @tab @dots{}       @tab @dots{}                                           @tab @dots{}
@item @code{surface9_red}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{123} @tab color of @code{surface9}
@item @code{surface9_green}  @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{104} @tab
@item @code{surface9_blue}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{238} @tab
@item @code{inside9_red}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{230} @tab inside color of @code{surface9}
@item @code{inside9_green}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{180} @tab
@item @code{inside9_blue}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{30}  @tab
@item @code{ambient}         @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{35}  @tab amount of ambient light
@item @code{diffuse}         @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{60}  @tab diffuse reflected light
@item @code{reflected}       @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{60}  @tab specular reflected light
@item @code{transmitted}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{60}  @tab spec. transmitted light
@item @code{smoothness}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{13}  @tab roughness
@item @code{transparency}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{80}  @tab transparency
@item @dots{}                @tab @dots{}       @tab @dots{}                                           @tab @dots{}
@item @code{ambient9}        @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{35}  @tab amount of ambient light
@item @code{diffuse9}        @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{60}  @tab diffuse reflected light
@item @code{reflected9}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{60}  @tab specular reflected light
@item @code{transmitted9}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{60}  @tab spec. transmitted light
@item @code{smoothness9}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{13}  @tab roughness
@item @code{transparency9}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{80}  @tab transparency
@item @code{light1_x}        @tab @code{double} @tab [@code{-9999}, @code{9999}]      @tab @code{-100} @tab position of 1st light source
@item @code{light1_y}        @tab @code{double} @tab [@code{-9999}, @code{9999}]       @tab @code{100} @tab
@item @code{light1_z}        @tab @code{double} @tab [@code{-9999}, @code{9999}]       @tab @code{100} @tab
@item @code{light1_vol}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{50}  @tab volume of 1st light source
@item @code{light1_red}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab color of 1st light source
@item @code{light1_green}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab
@item @code{light1_blue}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab
@item @dots{}                @tab @dots{}       @tab @dots{}                                           @tab @dots{}
@item @code{light9_x}        @tab @code{double} @tab [@code{-9999}, @code{9999}]       @tab @code{100} @tab position of 9th light source
@item @code{light9_y}        @tab @code{double} @tab [@code{-9999}, @code{9999}]       @tab @code{-100} @tab
@item @code{light9_z}        @tab @code{double} @tab [@code{-9999}, @code{9999}]       @tab @code{100} @tab
@item @code{light9_vol}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{0}   @tab volume of 9th light source
@item @code{light9_red}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab color of 9th light source
@item @code{light9_green}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab
@item @code{light9_blue}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab
@end multitable


@c Clipping
@c --------

@node Clipping, , Lighting Variables, List Of All Reserved Words
@section Clipping

@multitable {@code{cylinder_xaxis}} {@code{double}} {@code{cylinder_xaxis, }} {@code{none}} {additional clip region}
@item Reserved Word     @tab Type          @tab Range @tab Def.     @tab Description
@item @code{clip}       @tab @code{int}    @tab @{@code{none},@*
                                                  @code{sphere},@*
                                                  @code{cylinder_xaxis},@*
                                                  @code{cylinder_yaxis},@*
                                                  @code{cylinder_zaxis},@*
                                                  @code{cube}@}            @tab @code{none} @tab clipping area shape
@item @code{clip_front} @tab @code{double} @tab [@code{-9999}, @code{9999}] @tab @code{10}  @tab additional clip region
@item @code{clip_back}  @tab @code{double} @tab [@code{-9999}, @code{9999}] @tab @code{-10} @tab additional clip region
@item @code{radius}     @tab @code{double} @tab ]@code{0}, @code{9999}]     @tab @code{10}  @tab radius of clip region
@item @code{center_x}   @tab @code{double} @tab [@code{-9999}, @code{9999}] @tab @code{0}   @tab center of clip region
@item @code{center_y}   @tab @code{double} @tab [@code{-9999}, @code{9999}] @tab @code{0}   @tab center of clip region
@item @code{center_z}   @tab @code{double} @tab [@code{-9999}, @code{9999}] @tab @code{0}   @tab center of clip region
@end multitable

@c Constants
@c ---------

@c @node, Constants, , , List Of All Reserved Words
@c @section Constants

These constants all appreared before as values for some variables
(like @code{first}, @code{second}, @code{third} or @code{color_image_format}),
but since they're actually just "ordinary" constants and thus reserved words
they are listed here for the sake of completeness:

@multitable {@code{d_chain_regula_falsi}} {@code{string}} {Value} {@code{first}, @code{second}, @code{third}}
@item Constant           @tab Type        @tab Value    @tab Useful together with
@item @code{yes}         @tab @code{int}  @tab @code{1} @tab for any boolean variable
@item @code{no}          @tab @code{int}  @tab @code{0} @tab for any boolean variable
@item @code{translate}   @tab @code{int}  @tab @code{0} @tab @code{first}, @code{second}, @code{third}
@item @code{rotate}      @tab @code{int}  @tab @code{1} @tab @code{first}, @code{second}, @code{third}
@item @code{scale}       @tab @code{int}  @tab @code{2} @tab @code{first}, @code{second}, @code{third}
@item @code{parallel}    @tab @code{int}  @tab @code{0} @tab @code{perspective}
@item @code{central}     @tab @code{int}  @tab @code{1} @tab @code{perspective}
@item @code{ambient_light} @tab @code{int} @tab @code{1} @tab @code{illumination}
@item @code{diffuse_light} @tab @code{int} @tab @code{2} @tab @code{illumination}
@item @code{reflected_light} @tab @code{int} @tab @code{4} @tab @code{illumination}
@item @code{transmitted_light} @tab @code{int} @tab @code{8} @tab @code{illumination}
@end multitable

@bye
