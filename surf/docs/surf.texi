\input texinfo
@c $Id$
@setfilename surf.info
@settitle surf
@setcontentsaftertitlepage

@include version.texi

@ifinfo
This file documents @emph{surf} -- the visualization tool for real algebraic geometry.

Copyright (C) 1996-1997 Friedrich-Alexander-Universitaet Erlangen-Nuernberg,
1997-2001 Johannes Gutenberg-Universitaet Mainz.
@end ifinfo

@c title page
@c **********

@titlepage
@title surf
@subtitle visualization of real algebraic geometry
@author Stephan Endrass
@author Hans H@"ulf
@author R@"udiger @"Ortel
@author Ralf Schmitt
@author Kai Schneider
@author Johannes Beigel

@c copyright page
@page
@vskip 0pt plus 1filll
@multitable{Copyright @copyright{}} {1996--1997 Friedrich-Alexander-Universit@"at Erlangen-N@"urnberg,XX}
@item Copyright @copyright{}
@tab 1996--1997 Friedrich-Alexander-Universit@"at Erlangen-N@"urnberg,
@item
@tab 1997--2001 Johannes Gutenberg-Universit@"at Mainz.
@end multitable
@end titlepage


@c Top node
@c ********

@ifinfo

@node Top, Copying, , (dir)
@top surf

This document describes the usage of @emph{surf}, the visualization tool for
real algebraic geometry.

This document applies to version @value{VERSION} of @emph{surf}.
Although it may hopefully be well readable in info format with any info
reader (preferably XEmacs) or in HTML format, it will look best as DVI
file produced by @command{texi2dvi}: Just do a @kbd{make dvi} in the
@file{docs/} directory of the @emph{surf} distribution.

@menu
* Copying::
* Abstract::
* Acknowledgements::
* Overview::
* Introduction to surfs Command Language::
* Features::
* List Of All Reserved Words::
@end menu

@end ifinfo


@c Copying
@c *******

@node Copying, Abstract, top, top
@unnumbered Copying

@multitable{Copyright @copyright{}} {1996--1997 Friedrich-Alexander-Universit@"at Erlangen-N@"urnberg,XX}
@item Copyright @copyright{}
@tab 1996--1997 Friedrich-Alexander-Universit@"at Erlangen-N@"urnberg,
@item
@tab 1997--2001 Johannes Gutenberg-Universit@"at Mainz.
@end multitable

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

@c Abstract
@c ********

@node Abstract, Acknowledgements, Copying, top
@unnumbered Abstract

The aim was to have a tool to visualize some real algebraic geometry:
@itemize
@item
plane algebraic curves given as zero locus of a polynomial in two
variables,
@item
algebraic surfaces given as zero locus of a polynomial in three
variables,
@item
hyperplane sections of surfaces, i.e. algebraic space curves given as zero
locus of two polynomials in three variables: one polynomial
of arbitrary degree (the surface) and one linear polynomial (the
hyperplane),
@item
and lines on surfaces given by two points on a surface.
@end itemize

The algorithms should be stable enough not to be confused by
curve/surface singularities in codimension greater than one and the
degree of the surface or curve.  This has been achieved quite a bit. We
have drawn curves of degree up to 30 and surfaces of degree up to 20
successfully. However, there are examples of curves/surfaces of lower
degree where @emph{surf} fails to produce perfect images. This happens
especially if the equation of the curve/surface is not reduced. Best
results are achieved using reduced equations. On the other hand, @emph{surf}
displays the Fermat-curves accurately for degree up to 98.

@c Acknowledgements
@c ----------------

@node Acknowledgements, Overview, Abstract, top
@unnumbered Acknowledgements

(by Stephan Endrass, 1999)

I thank Prof. W. Barth (University Erlangen) for (en)forcing me to start
this project. Hans H@"ulf, R@"udiger @"Ortel and Kai Schneider have
spent lots of time on coding parts of @emph{surf}.

Some of the code has been copied from other places:

@itemize
@item
Writing SUN rasterfiles has been copied from Michael L. Mauldin's Fuzzy
PixMap (fbm) library version 1.2.
@item
The octree color reduction algorithm is copied from Ian Ashdown's
article @emph{Octree Color Quantization} in the C/C++ Users Journal
Vol. 13, Number 3, pp. 31-43.
@end itemize

We thank all these people who made their code free so that we could use
it.


@c Overview
@c ********

@node Overview, Introduction to surfs Command Language, Acknowledgements, top
@chapter Overview

@menu
* How to get surf::
* System Requirements::
* Starting surf::
* Scripting Language::
* Output::
* surf and make::
* Oddities and Bug Reports::
@end menu


@c How to get surf
@c ---------------

@node How to get surf, System Requirements, Overview, Overview
@section Hot to get @emph{surf}

A source tarball of @emph{surf} is available via HTTP and FTP at
the @emph{surf} home page
@url{http://surf.sourceforge.net}

An official Debian package is hopefully avaiable on your local Debian
mirror soon. Just type @command{apt-get install surf} as usal.

For information about how to compile and install the source
distribution of @emph{surf}, please read the @file{README} and
@file{INSTALL} files in the top level directory of the distribution,
or simply do the habitually

@example
$ ./configure
$ make
$ su
# make install
@end example


@c System Requirements
@c -------------------

@node System Requirements, Starting surf, How to get surf, Overview
@section System Requirements

To compile @emph{surf}, the following software is needed:

@itemize
@item
an ISO C++ compiler (GCC version 2.95 or higher should work, too),
@item
@command{make}
@item
GNU @command{flex} version 2.5 or higher (minor versions should
  work also, but @command{lex} does @emph{not} suffice),
@item
Berkeley @command{yacc} or GNU @command{bison},
@item
GNU MP (gmp) version 2 or later
@end itemize

@c Starting surf
@c -------------

@node Starting surf, Scripting Language, System Requirements, Overview
@section Starting @emph{surf}

@emph{surf} is started by typing @kbd{surf} together with some filenames
of @emph{surf} script files on the command line. Optional arguments are:
@itemize
@item
@option{--quiet}/@option{-q}: Don't print any useless output.
@item
@option{--help}/@option{-h}: Display option summary and exit.
@item
@option{--version}/@option{-v}: Print version, copyright notice and exit.
@end itemize

If you don't pass any script files, @emph{surf} will read commands from
standard input. Thus it's possible to pipe output from another program
to @emph{surf}:
@example
    $ another_proggy | surf
@end example

To check out the examples given in this manual just enter them with
an editor of your choice (If you haven't chosen yet, just take XEmacs!),
save them and pass them as arguments to @emph{surf}:
@example
    $ surf my_1st_script.pic
@end example

Historically, the typical filename extension for @emph{surf} scripts is
@file{.pic} (which is the extension all the example scripts in the
@file{examples/} directory of @emph{surf}'s source distribution have),
but there's no particular extension required.


@c Scripting Language
@c ------------------

@node Scripting Language, Output, Starting surf, Overview
@section Scripting Language

@emph{surf} is designed to visualize algebraic curves and surfaces.  As
already noted, this is done by writing scripts and let @emph{surf}
execute them. Writing scripts may seem a bit circumstantiol. But in fact
it's often much more powerful than a graphical interface and it comes in
very handy if you want to fiddle with your polynomials before rendering
them or if you wish to automate some time-consuming calculations.

On the other hand it's often useful to have some kind of interaction to
"play" with the curves and surfaces before producing the final output.
To do this just install and use the separate graphical frontend
@emph{gtksurf}. @emph{gtksurf} uses @emph{surf} as a kernel to let it
do the Real Work. If you don't already have it on your hard disk, you'll
find @emph{gtksurf} on @emph{surf}'s homepage:
@url{http://surf.sourceforge.net}

Please note that @emph{gtksurf} is by no means required to use
@emph{surf}. @emph{surf} compiles just fine without any X or GTK library
on your system. Maybe you remember older @emph{surf} versions, where the
kernel and the graphical frontend weren't separated. This separation has
been a design decision to make the development of both parts easier and
to allow users to install @emph{surf} on systems without all the libraries
needed for a nifty GUI program like @emph{gtksurf}.

You will find some sample scripts together with @emph{surf}'s
distribution. They are stored in the @file{examples/} directory.


@c Output
@c ------

@node Output, surf and make, Scripting Language, Overview
@section Output

@emph{surf} calculates both color and black & white images.

Color images can currently be stored in the following formats: JPEG,
PNG, PPM, Sun Rasterfile, TIFF and XPM. If it makes sense with the
chosen file format, one can choose a convenient colormap among: Netscape
216 color cube (8 bit), optimized by an octree algorithm (8 bit) and
true color (24 bit).

Black & white images can be stored in the following formats:
Postscript, Encapsulated Postscript (EPS), TIFF, XBM and PBM.

@c surf and make
@c -------------

@node surf and make, Oddities and Bug Reports, Output, Overview
@section @emph{surf} and @command{make}

@emph{surf} can be invoked from @command{make}. This comes in quite
handy when visualising a series of curves/surfaces. Suppose there are
script files @file{s1.pic}, @file{s2.pic}, @dots{}, @file{sn.pic} which
create during execution images @file{s1.png}, @file{s2.png}, @dots{},
@file{sn.png}. If for example GIF is the desired image file format, an
appropriate @file{Makefile} might look like:

@example
    #!/bin/bash
    #
    SURF    = surf
    RM      = /bin/rm -f
    CONVERT = convert
    #
    OBJS    = s1.gif s2.gif .... sn.gif
    #
    .SUFFIXES: .pic .gif
    #
    .pic.gif:
    	$(SURF)    $<
    	$(CONVERT) $*.png $*.gif
    	$(RM)      $*.png
    #
    all: $(OBJS)
    #
    clean:
    	$(RM) *.gif
    #
    # end of Makefile
@end example

Here, @command{convert} is the Image Magick image format converter.

@c Oddities and Bug Reports
@c ------------------------

@node Oddities and Bug Reports, , surf and make, Overview
@section Oddities and Bug Reports

In case you find any bug, please use the bug tracking system
on @emph{surf}'s project page at SourceForge:
@url{http://sourceforge.net/tracker/?group_id=3275}


@c Introduction to surf's Command Language
@c ***************************************

@node Introduction to surfs Command Language, Features, Overview, top
@chapter Introduction to @emph{surf}'s Command Language

@menu
* Data Types::
* Operators::
* Mathematical Functions::
* String Functions::
* Polynomial Functions::
* First Examples::
* Conditional Statements::
@end menu

@c Data Types
@c ----------

@node Data Types, Operators, Introduction to surfs Command Language, Introduction to surfs Command Language
@section Data Types

The language used in @emph{surf}'s scripts is quite simple.  It has got
a (very restricted) C-like syntax. There is no comma separator like in
C. Declaring a name twice results in an error. The scope of the name
begins at the point of its declaration and lasts until the end of the
file. There is no method of undeclaring a name. Both C-style
(@code{/*} @dots{} @code{*/}) and C++-style (@code{//} @dots{}) comments
are allowed.

The language provides the following four data types:
@itemize
@item
@code{int} (integer),
@item
@code{double} (double precision floating point value),
@item
@code{string} (any ""-quoted string) and
@item
@code{poly} (any polynomial in @code{x}, @code{y} and @code{z}).
@end itemize

So a valid declaration/initialisation looks like:
@itemize
@item
@code{int a = 3;} or @code{int a; a = 3;}
@item
@code{double b = 3.3;} or @code{double b; b = 3.3;}
@item
@code{string c = "test.ppm";} or @code{string c; c = "test.ppm";}
@item
@code{poly d = (x - 3)^3 - y^2 + z;} or @code{poly d; d = (x - 3)^3 - y^2 + z;}
@end itemize

@c Operators
@c ---------

@node Operators, Mathematical Functions, Data Types, Introduction to surfs Command Language
@section Operators

The following arithmetic operators are implemented:

@multitable @columnfractions .1 .2 .7
@c {Operator:} {greater or equal} {@{int,double,poly@}-@{int,double,poly@}}
@item Operator: @tab Meaning: @tab Valid Data Types:
@item @code{+}   @tab binary plus    @tab @{@code{int}, @code{double}, @code{poly}@} @code{+} @{@code{int}, @code{double}, @code{poly}@}
@item @code{+}   @tab concatenation  @tab @{@code{string}@} @code{+} @{@code{string}@}
@item @code{+}   @tab unary plus     @tab @code{+}@{@code{int}, @code{double}, @code{poly}@}
@item @code{-}   @tab binary minus   @tab @{@code{int}, @code{double}, @code{poly}@} @code{-} @{@code{int}, @code{double}, @code{poly}@}
@item @code{-}   @tab unary minus    @tab @code{-}@{@code{int}, @code{double}, @code{poly}@}
@item @code{*}   @tab multiplication @tab @{@code{int}, @code{double}, @code{poly}@}@code{*}@{@code{int}, @code{double}, @code{poly}@}
@item @code{/}   @tab division       @tab @{@code{int}, @code{double}, @code{poly}@}@code{/}@{@code{int}, @code{double}@}
@item @code{%}   @tab remainder      @tab @{@code{int}@}@code{%}@{@code{int}@}
@item @code{^}   @tab power          @tab @{@code{int}, @code{double}@}@code{^}@{@code{int}, @code{double}@}@*
                                          @{@code{poly}@}@code{^}@{@code{int}@}
@item @code{( )} @tab brackets       @tab @code{(}@{@code{int}, @code{double}, @code{poly}@}@code{)}
@item @code{=}   @tab assignment     @tab @{@code{poly}@} @code{=} @{@code{int}, @code{double}, @code{poly}@}@*
                                          @{@code{double}@} @code{=} @{@code{int}, @code{double}@}@*
                                          @{@code{int}@} @code{=} @{@code{int}@}@*
                                          @{@code{string}@} @code{=} @{@code{string}@}
@item @code{==}  @tab equal          @tab @{@code{int}, @code{double}@} @code{==} @{@code{int}, @code{double}@}
@item @code{!=}  @tab not equal      @tab @{@code{int}, @code{double}@} @code{!=} @{@code{int}, @code{double}@}
@item @code{<}   @tab smaller than   @tab @{@code{int}, @code{double}@} @code{<} @{@code{int}, @code{double}@}
@item @code{<=}  @tab smaller or equal @tab @{@code{int}, @code{double}@} @code{<=} @{@code{int}, @code{double}@}
@item @code{>}   @tab greater than   @tab @{@code{int}, @code{double}@} @code{>} @{@code{int}, @code{double}@}
@item @code{>=}  @tab greater or equal @tab @{@code{int}, @code{double}@} @code{>=} @{@code{int}, @code{double}@}
@end multitable

The precedence of operators is copied from C.


@c Mathematical Functions
@c ----------------------

@node Mathematical Functions, String Functions, Operators, Introduction to surfs Command Language
@section Mathematical Functions

There are some built-in math functions:

@multitable {@code{arctan()}} {arcus tangens} {@code{pow(@{double@}, @{int, double@})}} {returns}
@item Function:     @tab Meaning:      @tab Valid Argument:              @tab Returns:
@item @code{sqrt()} @tab square root   @tab @code{sqrt(@{int, double@})}   @tab @code{double}
@item @code{pow()}  @tab power         @tab @code{pow(@{int@}, @{int, double@})} @*
                                    @code{pow(@{double@},@{int,double@})} @tab @code{double}
@item @code{sin()}  @tab sine          @tab @code{sin(@{int, double@})}    @tab @code{double}
@item @code{cos()}  @tab cosine        @tab @code{cos(@{int, double@})}    @tab @code{double}
@item @code{arcsin()} @tab arcus sine    @tab @code{arcsin(@{int, double@})} @tab @code{double}
@item @code{arccos()} @tab arcus cosine  @tab @code{arccos(@{int, double@})} @tab @code{double}
@item @code{tan()}  @tab tangens       @tab @code{tan(@{int, double@})}    @tab @code{double}
@item @code{arctan()} @tab arcus tangens @tab @code{arctan(@{int, double@})} @tab @code{double}
@end multitable

@c String Functions
@c ----------------

@node String Functions, Polynomial Functions, Mathematical Functions, Introduction to surfs Command Language
@section String Functions

There are two functions returning strings:

@multitable {@code{istostrn}} {@code{itostrn(@{int@}, @{int@}) }} {@code{string} of spec. length}
@item Function:      @tab Valid Arguments:                 @tab Returns:
@item @code{itostr}  @tab @code{itostr(@{int@})}          @tab @code{string}
@item @code{itostrn} @tab @code{itostrn(@{int@}, @{int@})} @tab @code{string} of spec. length
@end multitable

@code{itostr()} converts its @code{int} argument to a @code{string}
without blanks. For example, @code{itostr(31)} returns @code{"31"}.

@code{itostrn()} allows to specify the length of the @code{string}.
For example: @code{itostrn(3, 88)} returns @code{"088"},
@code{itostrn(4, 88)} returns @code{"0088"}.


@c Polynomial Functions
@c --------------------

@node Polynomial Functions, First Examples, String Functions, Introduction to surfs Command Language
@section Polynomial Functions

Some functions work on polynomials:

@multitable {Function:} {Hesse surface} {@code{rotate(@{poly@}, @{double@}, @{xAxis, yAxis, zAxis@}) }} {Ret.:}
@item Function:     @tab Meaning:      @tab Valid Arguments:                 @tab Ret.:
@item @code{deg}    @tab degree        @tab @code{deg(@{poly@})}             @tab @code{int}
@item @code{len}    @tab length        @tab @code{len(@{poly@})}             @tab @code{int}
@item @code{diff}   @tab derivative    @tab @code{diff(@{poly@}, @{x, y, z@})}  @tab @code{poly}
@item @code{rotate} @tab rotation      @tab @code{rotate(@{poly@}, @{double@}, @{xAxis, yAxis, zAxis@})} @tab @code{poly}
@item @code{hesse}  @tab Hesse surface @tab @code{hesse(@{poly@})}           @tab @code{poly}
@end multitable


@c First Exapmles
@c --------------

@node First Examples, Conditional Statements, Polynomial Functions, Introduction to surfs Command Language
@section First Examples

Values can be passed to @emph{surf} by setting global variables. The most
important two global variables are @code{curve} and @code{surface},
which should be set to the polynomial whose zero set should be
visualized. So the shortest effective script contains only four lines,
for example:
@itemize
@item
1st example: Draw the Newton knot.
@example
        curve = y^2 - x^2*(x + 1);
        draw_curve;
        filename = "newton.jpg";
        save_color_image;
@end example
@item
2nd example: Draw a sphere.
@example
        surface = x^2 + y^2 + z^2 - 80;
        draw_surface;
        filename = "sphere.png";
        save_color_image;
@end example
@end itemize

@c Conditional Statements
@c ----------------------

@node Conditional Statements, , First Examples, Introduction to surfs Command Language
@section Conditional Statements

There are no @code{for} and no @code{while} statements.
There is only the crude
@example
    if(INTEGER-EXPRESSION) goto LABEL;
@end example
which you might remember from your early BASIC sessions.

Here @code{INTEGER-EXPRESSION} can be arbitrary complicated as long as it
results in an integer. @code{LABEL} is something like @code{NAME}
which has occurred before as @code{NAME:}. Consider the example
@example
    int i = 0;
    loop:
        surface = x^2 + y^2 + z^2 - (i + 1.0)/2.0;
        clear_screen;
        draw_surface;
        filename = "sphere" + itostrn(2, i) + ".xpm";
        save_color_image;
        i = i + 1;
    if(i < 50) goto loop;
@end example
which obviously draws fifty spheres of increasing radius 
and saves them into the X Pixmap files:
@file{sphere00.xpm}, @dots{} @file{sphere49.xpm}.

@c Features
@c ********

@node Features, List Of All Reserved Words, Introduction to surfs Command Language, top
@chapter Features

In this section most features of @emph{surf} are explained.  For a complete
reference to the command language, have a look at
@ref{List Of All Reserved Words}.

@menu
* Plane Curves::
* Surfaces::
* Hyperplane Sections::
* Multiple Curves/Surfaces::
* Graphs and Isolines::
* Antialiasing Surfaces::
* Animations::
* Stereo Pictures::
* Black & White Images::
* Algorithms::
* Image Formats::
@end menu


@c Plane Curves
@c ------------

@node Plane Curves, Surfaces, Features, Features
@section Plane Curves

To draw a plane curve, set the global variable @code{curve} to the
polynomial describing the curve and call the @code{draw_curve}
command. To see the result, save the image by setting the
@code{filename} variable and calling @code{save_color_image}.
Example script:
@example
        curve = x^2 + y^2 - 1;
        draw_curve;
        filename = "circle.xpm";
        save_color_image;
@end example

By default the curve is drawn inside the rectangle
@ifnottex
@math{-10.0 <= x, y <= 10.0}
@end ifnottex
@tex
$-10.0 \le x, y \le 10.0 $
@end tex
and is clipped at a circle with radius 10.0.  The x-axis is
horizontal pointing to the right, the y-axis is vertical and points
upwards. By default the image size is 200x200 pixels.  The image size
can be altered by setting the variables @code{width} and @code{height}.

A different origin can be specified by setting
@code{origin_x} and @code{origin_y}.
A rotation with center at @math{(0, 0)} can be specified by setting
@code{rot_z}. The curve may be scaled by setting
@code{scale_x} and @code{scale_y}.

The width of the curve is determined by the variable @code{curve_width}
and the gamma value by @code{curve_gamma} respectively.  A high gamma
value sharpens the curve, whereas a low value blurs the curve.

The clipping area can be specified by setting @code{clip}. For a curve
the only reasonable values are @code{sphere} or @code{none}. When
choosing @code{sphere} you may adjust its radius with the variable
@code{radius}.

An arbitrary color can be given to the curve by setting
@code{curve_red}, @code{curve_green} and @code{curve_blue} to
appropriate values between 0 and 255.

@c Surfaces
@c --------

@node Surfaces, Hyperplane Sections, Plane Curves, Features
@section Surfaces

To draw an algebraic surface, set the global variable @code{surface} to the
polynomial describing the surface and call @code{draw_surface}.
To see the result, set the @code{filename} variable and call
@code{save_color_image}. Example script:
@example
        surface = x^2 + y^2 + z^2 - 4;
        draw_surface;
        filename = "sphere.jpg";
        save_color_image;
@end example

By default, the surface is calculated inside the cube
@ifnottex
@math{-10.0 <= x, y, z <= 10.0}
@end ifnottex
@tex
$-10.0 \le x, y, z \le 10.0$
@end tex
and clipped at a sphere of radius 10.0.

The x-axis is horizontal pointing to the right, the y-axis is vertical
and points upwards. The z-axis points to you. The spectator is located
at @math{(0, 0, 25)} by default.

A different origin may be specified by setting @code{origin_x},
@code{origin_y} and @code{origin_z}.  To rotate the surface one can set
@code{rot_x} about x-axis @code{rot_y} and @code{rot_z} to appropriate
values. Rotation is performed in the following order: y-axis, x-axis,
z-axis.

To scale the surface set @code{scale_x}, @code{scale_y} and
@code{scale_z} to desired values.

It is also possible to switch from central perspective to parallel
perspective by setting @code{perspective} to @code{central} or
@code{parallel} respectively.

Illumination and color can be altered, too.  The direction of the normal
vector given by the gradient of the surface equation defines one side of
the surface which is regarded as outside. You can specify a color for
this side by setting @code{surface_red}, @code{surface_green} and
@code{surface_blue}. The other side of the surface (inside) can be given
a different color by specifying @code{inside_red}, @code{inside_green}
and @code{inside_blue}.

Currently only the Phong illumination model is implemented.
Therefore the intensity of the surface in one point consists of
four components which are calculated separately:
@itemize
@item
ambient light,
@item
diffuse light,
@item
reflected light and
@item transmitted light.
@end itemize

Ambient light is a constant which represents the light a point on the
surface receives from the whole environment (the sky, the floor, the
lawn @dots{})  but not from the light sources.

Diffuse light is the light the point receives from the light sources and
which is reflected equally in every possible direction. The amount of
diffuse light is independent of the spectator position, it is
proportional to the cosine of the angle between the normal vector and
the vector from the point to the light source.

Reflected light is the light from the light sources which is reflected
specular from the surface point. Its amount is proportional to a power
of the cosine of the angle between the vector from the point to the
spectator and the specular reflection vector from the light source. If a
high power of the cosine is taken, the surface will appear shiny,
whereas a low power of the cosine lets the surface look rough.  Therfore
the variable controlling this power is named @code{smoothness}.

Transmitted light comes in if a surface is transparent. A variable
called @code{transparence} specifies the percentage of light which
passes through the surface. Algebraic surfaces are infinitesimally
thin. However our eye is not used to such objects, so we pretend that
our surfaces have a constant @code{thickness}. Specifying a positive
@code{thickness} for a transparent surface results in a loss of
transparency in the places where the surface normal does not point to
the spectator.

These four light components are added with weights @code{ambient},
@code{diffuse}, @code{reflected} and @code{transmitted}.

The number of light sources is limited to nine. For every light source,
the position, the color and the intensity can be specified. See the next
chapter for a complete listing of these variables.

The shape of the clipping area is determined by the variable
@code{clip}. The center is specified via @code{center_x},
@code{center_y}, @code{center_z} and the radius via @code{radius}.
Additionally a front and a back clipping plane may be specified by
setting @code{clip_front} and @code{clip_back}.

@c Hyperplane Sections
@c -------------------

@node Hyperplane Sections, Multiple Curves/Surfaces, Surfaces, Features
@section Hyperplane Sections

To draw one or more hyperplane sections of an algebraic surface, just
specify the hyperplane by setting the global variable @code{plane} to
its equation.

The section is drawn when the command @code{cut_with_plane} is interpreted.
For example:
@example
    rot_x = 0.3; // a nice rotation
    rot_y = 0.2;

    // draw the steiner roman surface:
    surface = x^2*y^2  +y^2*z^2 + z^2*x^2 - 16*x*y*z;
    clear_screen;
    draw_surface;

    // draw a green hyperplane section
    curve_red = 0;
    curve_green = 255;
    curve_blue = 0;
    curve_width = 5;
    curve_gamma = 1.2;
    plane = x + y + z;
    cut_with_plane;

    // draw another one
    plane = x + y + z + 4.0;
    cut_with_plane;

    // save image:
    filename = "hyperplanesections.jpg";
    save_color_image;
@end example

The color of the hyperplane section can be set by specifying
@code{curve_red}, @code{curve_green} and @code{curve_blue}.  The width
of the section is altered by setting @code{curve_width} to any suitable
value. A high value of @code{curve_gamma} (eg. 10.0) makes the curve
look very pixelized, whereas a small value (eg. 1.0) makes the section
look blurred.

@c Multiple Curves/Surfaces
@c ------------------------

@node Multiple Curves/Surfaces, Graphs and Isolines, Hyperplane Sections, Features
@section Multiple Curves/Surfaces

Multiple curves can be drawn in script files just by @emph{not} clearing
the screen. This works fine for plane curves.  Just consider the
following example:
@example
    // draw a cubic
    curve = y^2 - x^2*(x - 1);
    draw_curve;

    // draw y-axis
    curve = x;
    draw_curve;
    
    // draw x-axis:
    curve = y;
    draw_curve;

    // save image:
    filename = "cubic.xpm";
    save_color_image;
@end example

Note that every curve will be drawn just over all curves that have been
drawn so far.

Multiple surfaces can be drawn by specifying up to nine surfaces in the
variables @code{surface}, @code{surface2}, @dots{},
@code{surface9}. Additionally it is possible to draw on every surface
any number of hyperplane sections.

@example
    rot_x = 0.69; // a nice rotation
    rot_y = 0.35;
    illumination = ambient_light +  // specify illumination model
                   diffuse_light +
                   reflected_light +
                   transmitted_light;
    transparence = 35;  // set transparence for surface no 1
    transparence2 = 35; // set transparence for surface no 2

    // first surface: a sphere
    surface = x^2 + y^2 + z^2 - 30;  

    // second surface: a red steiner surface
    surface2_red = 255;              
    surface2_green = 0;
    surface2_blue = 0;
    surface2 = x^2*y^2 + x^2*z^2 + y^2*z^2 - 16*x*y*z;

    draw_surface; // draw both surfaces

    // draw a green hyperplane section...
    curve_width = 5;
    curve_red = 0;
    curve_green = 255;
    curve_blue = 0;
    plane = x + y + z - 6.0;
    surf_nr = 1;           // ...on the sphere
    cut_with_plane;

    // draw a turquoise hyperplane section...
    curve_red = 0;
    curve_green = 255;
    curve_blue = 255;
    plane = x + y + z +4.0;                 
    surf_nr = 2;           // ...on the steiner surface
    cut_with_plane;

    // save the image
    filename = "multisurfs.jpg";
    save_color_image;
@end example

@c Graphs and Isolines
@c -------------------

@node Graphs and Isolines, Antialiasing Surfaces, Multiple Curves/Surfaces, Features
@section Graphs and Isolines

Given a polynomial function @math{f(x, y)} and a set of levels
@math{z1}, @dots{}, @math{zn}, @emph{surf} can visualize the graph @math{z =
f(x, y)} and all isolines for the levels @math{z1}, @dots{}, @math{zn}
as follows:
@example
    rot_x = -0.8;
    poly f = x^2 + y^2; // graph of (x,y) -> x^2 + y^2
    surface = z - f;
    draw_surface;      // draw the graph

    curve_width = 3;   // width of isolines
    int i = 1;
    loop:
        plane = z - i;
        cut_with_plane; // draw isoline f(x,y) = i
        i = i + 1;
    if(i < 10) goto loop;

    // save image
    filename = "isolines.jpg";
    save_color_image;
@end example

If however your function @math{f} is not polynomial, try to expand
calculate its Taylor series. Since the new root algorithms work fine
with polynomials of degree up to 30, you might approximate @math{f} by
its Taylor series. If your function is piecewise defined, better use
another program.

@c Antialiasing Surfaces
@c ---------------------

@node Antialiasing Surfaces, Animations, Graphs and Isolines, Features
@section Antialiasing Surfaces

Especially in animations aliasing is very disturbing. Therefore if
@code{antialiasing} is set to a value
@ifnottex
@math{n >= 1}
@end ifnottex
@tex
$n \ge 1$
@end tex
then in a second pass all pixels differing by a value of at least
@code{antialiasing_threshold} from one of their neighbours are
refined. Exactly
@ifnottex
@math{n^2+1}
@end ifnottex
@tex
$n^2 + 1$
@end tex
intensity values are calculated. In most
cases an antialiasing level of 4 will remove aliasing.

@c Animations
@c ----------

@node Animations, Stereo Pictures, Antialiasing Surfaces, Features
@section Animations

You can calculate a series of images with @emph{surf} and convert this
series of images to the movie format of your choice.
@example
    // --------------------------
    // the 4-nodal cubic rotating
    // --------------------------
    
    width = 200;  // set image size
    height = 200;
    
    double sf = 0.3;
    scale_x = sf; // set scaling
    scale_y = sf;
    scale_z = sf;

    double pi = 2*arccos(0); // define some constants
    double w2 = sqrt(2);
    
    // define tetrahedral coordinates
    poly p = 1 - z - w2*x;
    poly q = 1 - z + w2*x;
    poly r = 1 + z + w2*y;
    poly s = 1 + z -w2*y;

    // the cubic:
    poly cubic = 4*(p^3 + q^3 + r^3 + s^3) - (p + q + r + s)^3;

    int i = 0;
    loop:
        surface = rotate(cubic, 2*pi/100*i, zAxis); // rotate the cubic
        clear_screen;
        draw_surface; // draw the cubic
        filename = "cubic" + itostrn(3, i) + ".ras";
        save_color_image; // save the image
        i = i + 1;
    if(i < 100) goto loop; // repeat 100 times
@end example
Here some 100 Sun rasterfiles are created.  Afterwards you could use a
tool to convert these single images to a movie. For example with the
@command{convert} program from the ImageMagick suite you could type
@kbd{convert -delay 5 cubic*.ras cubic.gif} to create a GIF animation.


@c Stereo Pictures
@c ---------------

@node Stereo Pictures, Black & White Images, Animations, Features
@section Stereo Pictures

Have you ever watched one of those films with that red and green
glasses? @emph{surf} tries to accomplish exactly this effect when you set
@code{stereo_eye} to a value greater than zero.

The following situation is simulated: The spectator is located at
@math{(0,0, spectator z)} and the distance between his eyes is
@code{stereo_eye}. The surface will appear at the z-coordinate
@code{stereo_z}.  Furthermore it is possible to adjust to specific
red-green or red-blue glasses by setting @code{stereo_red} (left eye),
@code{stereo_green} and @code{stereo_blue} (right eye). In particular it
is assumed that the right eye wears the red glass.

@c Black & White Images
@c --------------------

@node Black & White Images, Dithering with Blue Noise, Stereo Pictures, Features
@section Black & White Images

If a color image of a surface/curve has been calculated, this image can
be mapped to a black and white image by calling one of the commands
@code{dither_surface} or @code{dither_curve}.  The second one is just
designed for dithering curves.

The appearance of the black and white image can be altered/adjusted in
several ways.  Since the mapping itself is done by dithering, the
dithering algorithm can be specified. Currently available are seven
algorithms coming in three groups:

@menu
* Dithering with Blue Noise::
* Dithering with Ordered Dither::
* Hybrid Methods::
* The Black & White Problem::
@end menu

@c Dithering with Blue Noise

@node Dithering with Blue Noise, Dithering with Ordered Dither, Black & White Images, Black & White Images
@subsection Dithering with Blue Noise

@itemize
@item Floyd-Steinberg filter
@item Jarvis, Judis and Ninke filter
@item Stucki filter
@end itemize

All three filters are based on the same idea of error
distribution. Floyd Steinberg is the simplest one, whereas Stucki
differs from Jarvis only by its weights. They tend to produce disturbing
patterns if they process large areas of intensity near 0.5. Therefore
one can let them proceed in a serpentine fashion, which reduces the
patterns. Nearly all patterns disappear if the weights are disturbed
randomly. The algorithms are best for use with low resolution printers,
typically 300 dpi. Some (most?) 600 dpi laser printers do not like these
algorithms, since they do not like isolated pixels.

@c Dithering with Ordered Dither

@node Dithering with Ordered Dither, Hybrid Methods, Dithering with Blue Noise, Black & White Images
@subsection Dithering with Ordered Dither

@itemize
@item Clustered dot ordered dither
@item Dispersed dot ordered dither
@end itemize
The clustered dot ordered dither is a fast method and produces
satisfying results in combination with high resolution printers (600 dpi
and more). The second algorithm is for use with low resolution
printers. Both perform no error distribution. Depending on the printer
resolution and the number of emulated gray levels, one can choose the
pattern size:
@itemize
@item 4 x 4 pixels: 16 gray levels,
@item 8 x 8 pixels: 64 gray levels or
@item 16 x 16 pixels: 256 gray levels.
@end itemize

@c Hybrid Methods

@node Hybrid Methods, The Black & White Problem, Dithering with Ordered Dither, Black & White Images
@subsection Hybrid Methods

@itemize
@item Knuth's dot diffusion
@item Knuth's smooth dot diffusion
@end itemize
Both algorithms combine clustered dot ordered dither and error
distribution. Depending on the printer resolution on can choose the
number of barons in a 8x8 matrix to be
@itemize
@item 1 for resolutions of 1200 dpi or above or
@item 2 for resolutions of 600 dpi or above.
@end itemize
The barons are the bad guys in a matrix which get all the error left
over from the good guys.

@c The Black & White Problem

@node The Black & White Problem, Algorithms, Hybrid Methods, Black & White Images
@subsection The Black & White Problem

The surfaces on black and white images often don't look very impressive;
often it is hard to detect the edges of a surface. An algorithm called
enhancing the edges avoids this drawback. This algorithm takes a value
@code{alpha} in @math{[0, 1]} as input.  Best results are achieved with
@code{alpha} around 0.9.

The intensity of the background on the black and white image can be
specified by altering the value @code{background} to any value in
@math{[0, 1]}. Here 0 is black whereas 1 means white.

If @code{tone_scale_adjustment} is set to @code{yes}, intensity values
between 0 and 0.1 are mapped to 0, values between 0.1 and 0.9 linearly
to @math{[0, 1]} and values between 0.9 and 1 to 1. This is used to
enhance the contrast of an image. Additionally, @code{gamma_correction}
can be set to @code{yes} to correct the linearity of an output device.

By specifying @code{pixel_size} one can correct the printer pixel size:
A value of 50 means that the radius of a pixel is exactly half the
distance between two neighbouring pixels. A value of 100 says that the
radius of a pixel is exactly the distance between two neighbouring
pixels.

@c Algorithms
@c ----------

@node Algorithms, Image Formats, The Black & White Problem, Features
@section Algorithms

The heart of @emph{surf} is an algorithm which determines all roots of a
polynomial in one variable. Currently you can choose between six
methods for the @code{root_finder} variable:
@itemize
@item @code{d_chain_bisection}
@item @code{d_chain_regula_falsi}
@item @code{d_chain_pegasus}
@item @code{d_chain_anderson_bjoerck}
@item @code{d_chain_newton}
@item @code{bezier_all_roots}
@end itemize
The first five methods use a
chain of derivatives to determine intervals where the polynomial has
exactly one root. They differ by the iteration method which is used to
find the roots in these intervals. Some of the iteration methods were
just implemented out of academic interest. However, they all work. The
last method uses Rockwoods all roots algorithm: the polynomial is
converted into a bezier function and the roots of the bezier function
are approximated by the roots of the control polygon.

For curves/surfaces of degree less than ten, all methods work.  When the
degree gets higher, best results are achieved by the bisection, the
Newton and the bezier all roots method. At last, for a degree higher
than 30 only the bisection methods seems to work (up to degree 50). If a
curve has multiple components, the bisection and the Newton method tend
to produce the best results.

Moreover it is possible to specify a numerical precision @code{epsilon}
which is used in all root finders.  Additionally the maximal number of
@code{iterations} of the iteration methods can be specified.

@c Image Formats
@c -------------

@node Image Formats, , Algorithms, Features
@section Image Formats

@emph{surf} can store color images in one of several file formats. Some
of them may not be available if you don't have installed the appropriate
libraries. By setting @code{color_file_format} you can choose between:
@multitable @columnfractions .1 .9
@item @code{auto} @tab format is automatically chosen by looking at the
                       extension of @code{filename}
@item @code{jpeg} @tab JPEG (24 bit)
@item @code{png}  @tab PNG (8 bit)
@item @code{ppm}  @tab Portable Pixmap (24 bit)
@item @code{sun}  @tab Sun Rasterfile (24 bit)
@item @code{tiff} @tab TIFF (24 bit)
@item @code{xpm}  @tab X Pixmap (8 bit)
@end multitable
Additionally the value of @code{color_file_colormap} can be chosen
among:
@multitable {@code{Optimized}} {optimized by an octree algorithm (8 bit) and}
@item @code{netscape}  @tab Netscape 216 color cube (8 bit)
@item @code{optimized} @tab optimized by an octree algorithm (8 bit)
@item @code{truecolor} @tab true color (24 bit)
@end multitable
The first colormap is just the 6x6x6 colormap Netscape uses.  The second
one results from an octree algorithm which chooses the most used 216
colors among all colors of the image. @code{color_file_colormap} is only
evaluated if it makes sense with the chosen @code{color_file_format}.
The quality of JPEG images can be adjusted by setting
@code{jpeg_quality} to an appropriate value between 0 and 100.

@emph{surf} can store black and white images these formats (set the variable
@code{dither_file_format}):
@multitable @columnfractions .2 .8
@item @code{auto}       @tab try to guess format from extension of @code{filename}
@item @code{eps}        @tab Encapsulated Postscript
@item @code{pbm}        @tab Portable Bitmap
@item @code{postscript} @tab Postscript
@item @code{tiff}       @tab TIFF
@item @code{xbm}        @tab X Bitmap
@end multitable
For Postscript, Encapsulated Postscript and TIFF the resolution may be
specified by setting @code{resolution}) to the desired dpi value.


@c List Of All Reserved Words
@c **************************

@node List Of All Reserved Words, , Features, top
@chapter List Of All Reserved Words

A reserved word in @emph{surf}'s language is either a command, a
function or a global variable. A command is invoked without
parameters. Global variables are either constant or may be altered.

@menu
* Main Variables::
* Drawing Commands::
* Positioning::
* Saving Images::
* Image Variables::
* Lighting Variables::
* Dithering Variables::
* Clipping Variables::
* Algorithm Variables::
* Constants::
@end menu


@c Main Variables
@c --------------

@node Main Variables, Drawing Commands, List Of All Reserved Words, List Of All Reserved Words
@section Main Variables

@multitable {Reserved Word} {@code{string}} {@{64, @dots{}, 3000@}} {Default} {height of surface image}
@item Reserved Word @tab Type @tab Range @tab Default @tab Description
@item @code{curve}    @tab @code{poly} @tab --- @tab @code{0} @tab polynomial of curve
@item @code{curve_red}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab curve color
@item @code{curve_green} @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab
@item @code{curve_blue}  @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab
@item @code{curve_width} @tab @code{double} @tab any @tab @code{1} @tab width of curve
@item @code{curve_gamma} @tab @code{double} @tab ]@code{0},
@ifnottex
oo
@end ifnottex
@tex
$\infty$
@end tex
[ @tab @code{4.0} @tab gamma value of curve
@item @code{surface}  @tab @code{poly} @tab --- @tab @code{0} @tab polynomial of surface
@item @code{surface2} @tab @code{poly} @tab --- @tab @code{0} @tab polynomial of surface2
@item @dots{}         @tab @dots{}  @tab @dots{} @tab @dots{} @tab @dots{}
@item @code{surface9} @tab @code{poly} @tab --- @tab @code{0} @tab polynomial of surface9
@item @code{plane}    @tab @code{poly} @tab linear @tab @code{0} @tab equation of hyperplane
@item @code{width}    @tab @code{int}  @tab @{@code{64}, ..., @code{3000}@} @tab @code{200} @tab width of image
@item @code{height}   @tab @code{int}  @tab @{@code{64}, ..., @code{3000}@} @tab @code{200} @tab height of image
@item @code{surf_nr}  @tab @code{int}  @tab @{@code{1},..., @code{9}@} @tab @code{1} @tab surface which is used for @code{cut_with_plane}
@end multitable

@c Drawing Commands
@c ----------------
@node Drawing Commands, Positioning, Main Variables, List Of All Reserved Words
@section Drawing Commands

@multitable @columnfractions 0.2 0.8
@item Reserved Word: @tab Description:
@item @code{clear_screen}        @tab erase the image
@item @code{draw_curve}          @tab draw the curve defined by the global
                                      polynomial @code{curve}
@item @code{draw_surface}        @tab draw the surfaces defined by the global
                                      polynomials @code{surface}, @code{surface2},
                                      @dots{}, @code{surface9}
@item @code{cut_with_plane}      @tab draw the hyperplane section defined
                                      defined by the linear polynomial @code{plane}
@item @code{dither_surface}      @tab convert color image to a dithered
                                      black and white image
@item @code{dither_curve}        @tab convert color image to a dithered
                                      b&w image (for curves only)
@end multitable

@c Positioning
@c -----------

@node Positioning, Saving Images, Drawing Commands, List Of All Reserved Words
@section Positioning

@multitable {Reserved Word} {@code{double}} {]@code{-9999}, @code{9999}[} {@code{translate}} {spectator distance from origin}
@item Reserved Word @tab Type @tab Range @tab Default @tab Description
@item @code{origin_x}    @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{0} @tab x position of origin
@item @code{origin_y}    @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{0} @tab y position of origin
@item @code{origin_z}    @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{0} @tab z position of origin
@item @code{spec_z}      @tab @code{double} @tab ]@code{0}, @code{9999}[     @tab @code{100} @tab spectator distance from origin
@item @code{rot_x}       @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{0} @tab rotation angle of surface about the x-axis
@item @code{rot_y}       @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{0} @tab rotation angle of surface about the y-axis
@item @code{rot_z}       @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{0} @tab rotation angle of surface about the z-axis
@item @code{scale_x}     @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{1} @tab ratio surface is scaled in direction of the x-axis
@item @code{scale_y}     @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{1} @tab ratio surface is scaled in direction of the y-axis
@item @code{scale_z}     @tab @code{double} @tab ]@code{-9999}, @code{9999}[ @tab   @code{1} @tab ratio surface is scaled in direction of the z-axis
@item @code{perspective} @tab @code{int}    @tab @{@code{parallel},@* @code{central}@} @tab @code{parallel} @tab perspective to use
@item @code{first}       @tab @code{int}    @tab @{@code{translate},@* @code{rotate},@* @code{scale}@} @tab @code{translate} @tab first performed action
@item @code{second}      @tab @code{int}    @tab @{@code{translate},@* @code{rotate},@* @code{scale}@} @tab @code{rotate}  @tab second performed action
@item @code{third}       @tab @code{int}    @tab @{@code{translate},@* @code{rotate},@* @code{scale}@} @tab @code{scale} @tab third performed action
@end multitable

@c Saving Images
@c -------------

@node Saving Images, Image Variables, Positioning, List Of All Reserved Words
@section Saving Images

@multitable {@code{save_dithered_image}} {@code{string}} {[@code{75}, @dots{}, @code{9999}] } {@code{truecolor}} {save color image in file}
@item Reserved Word              @tab Type          @tab Range @tab Def.     @tab Description
@item @code{save_color_image}    @tab cmd.          @tab ---   @tab ---       @tab save color image in file defined by the global string @code{filename}
@item @code{save_dithered_image} @tab cmd.          @tab ---   @tab ---       @tab save dithered black and white image in file defined by the global string @code{filename}
@item @code{filename}            @tab @code{string} @tab any   @tab @code{""} @tab filename used in @code{save_color_image} and @code{save_dithered_image}
@item @code{color_file_format}   @tab @code{int}    @tab @{@code{auto},@*
                                                           @code{jpeg},@*
                                                           @code{png},@*
                                                           @code{ppm},@*
                                                           @code{sun},@*
                                                           @code{tiff},@*
                                                           @code{xpm}@} @tab @code{auto} @tab file format used in @code{save_color_image}
@item @code{color_file_colormap} @tab @code{int}    @tab @{@code{netscape},@*
                                                           @code{optimized},@*
                                                           @code{truecolor}@} @tab @code{truecolor} @tab colormap type
@item @code{dither_colors}       @tab @code{int}    @tab @{@code{yes}, @code{no}@} @tab @code{yes} @tab color dithering
@item @code{dither_steps}        @tab @code{double} @tab [@code{5}, @dots{}...,@code{255}] @tab @code{20.0} @tab steps of dithering
@item @code{dither_file_format}  @tab @code{int}    @tab @{@code{auto},@*
                                                           @code{eps},@*
                                                           @code{pbm},@*
                                                           @code{postscript},@*
                                                           @code{tiff},@*
                                                           @code{xbm}@} @tab @code{auto} @tab file format used in @code{save_dithered_image}
@item @code{resolution}          @tab @code{int}    @tab [@code{75}, @dots{}, @code{9999}] @tab @code{300}  @tab (printer) resolution
@end multitable

@c Image Variables
@c ---------------

@node Image Variables, Lighting Variables, Saving Images, List Of All Reserved Words
@section Image Variables

@multitable {@code{antialiasing_threshold}} {@code{string}} {@code{postscript,}} {@code{auto}} {save color image in file defined}
@item Reserved Word                 @tab Type          @tab Range @tab Def.     @tab Description
@item @code{normalize}              @tab @code{int}    @tab @{@code{yes}, @code{no}@} @tab @code{no} @tab normalize image
@item @code{normalize_factor}       @tab @code{double} @tab ]@code{0}, @dots{}, @code{5}] @tab @code{1.0} @tab multiply with
@item @code{antialiasing}           @tab @code{int}    @tab @{@code{1}, @dots{}, @code{8}@} @tab @code{1} @tab level of antialiasing
@item @code{antialiasing_threshold} @tab @code{double} @tab ]@code{0}, @code{1}[ @tab @code{0.1} @tab threshold
@item @code{antialiasing_radius}    @tab @code{double} @tab [@code{0.5}, @code{2}] @tab @code{2.0} @tab radius 
@item @code{depth_cueing}           @tab @code{int}    @tab @{@code{yes}, @code{no}@} @tab @code{no} @tab use depth cueing
@item @code{depth_value}            @tab @code{double} @tab [@code{-1000}, @code{10}[ @tab @code{-14.0} @tab depth of mist
@item @code{stereo_eye}             @tab @code{double} @tab [@code{-100}, @code{100}] @tab @code{0.0} @tab eye distance
@item @code{stereo_z}               @tab @code{double} @tab [@code{-30}, @code{30}] @tab @code{5.0} @tab distance from screen
@item @code{stereo_red}             @tab @code{double} @tab [@code{0}, @code{1}] @tab @code{1.0} @tab left eye red
@item @code{stereo_green}           @tab @code{double} @tab [@code{0}, @code{1}] @tab @code{0.7} @tab right eye green
@item @code{stereo_blue}            @tab @code{double} @tab [@code{0}, @code{1}] @tab @code{0.0} @tab right eye blue
@end multitable

@c Lighting Variables
@c ------------------

@node Lighting Variables, Clipping Variables, Image Variables, List Of All Reserved Words
@section Lighting Variables

@multitable {@code{surface9_green}} {@code{double}} {@code{transmitted_light}} {@code{amb... +}} {volume of 9th light source}
@item Reserved Word          @tab Type          @tab Range @tab Def.     @tab Description
@item @code{illumination}    @tab @code{int}    @tab any sum of@* @code{ambient_light}, @code{diffuse_light}, @code{reflected_light} and@* @code{transmitted_light} @tab @code{amb.. + diff.. + refl..} @tab illumination model
@item @code{surface_red}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{123} @tab color of @code{surface}
@item @code{surface_green}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{104} @tab
@item @code{surface_blue}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{238} @tab
@item @code{inside_red}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{230} @tab inside color of @code{surface}
@item @code{inside_green}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{180} @tab
@item @code{inside_blue}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{30}  @tab
@item @code{surface2_red}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{123} @tab color of @code{surface2}
@item @code{surface2_green}  @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{104} @tab
@item @code{surface2_blue}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{208} @tab
@item @code{inside2_red}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{230} @tab inside color of @code{surface2}
@item @code{inside2_green}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{180} @tab
@item @code{inside2_blue}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{30}  @tab
@item @dots{}                @tab @dots{}       @tab @dots{}                                           @tab @dots{}
@item @code{surface9_red}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{123} @tab color of @code{surface9}
@item @code{surface9_green}  @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{104} @tab
@item @code{surface9_blue}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{238} @tab
@item @code{inside9_red}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{230} @tab inside color of @code{surface9}
@item @code{inside9_green}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{180} @tab
@item @code{inside9_blue}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{30}  @tab
@item @code{ambient}         @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{35}  @tab amount of ambient light
@item @code{diffuse}         @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{60}  @tab diffuse reflected light
@item @code{reflected}       @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{60}  @tab specular reflected light
@item @code{transmitted}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{60}  @tab spec. transmitted light
@item @code{smoothness}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{13}  @tab roughness
@item @code{transparency}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{80}  @tab transparency
@item @dots{}                @tab @dots{}       @tab @dots{}                                           @tab @dots{}
@item @code{ambient9}        @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{35}  @tab amount of ambient light
@item @code{diffuse9}        @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{60}  @tab diffuse reflected light
@item @code{reflected9}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{60}  @tab specular reflected light
@item @code{transmitted9}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{60}  @tab spec. transmitted light
@item @code{smoothness9}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{13}  @tab roughness
@item @code{transparency9}   @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{80}  @tab transparency
@item @code{light1_x}        @tab @code{double} @tab [@code{-9999}, @code{9999}]      @tab @code{-100} @tab position of 1st light source
@item @code{light1_y}        @tab @code{double} @tab [@code{-9999}, @code{9999}]       @tab @code{100} @tab
@item @code{light1_z}        @tab @code{double} @tab [@code{-9999}, @code{9999}]       @tab @code{100} @tab
@item @code{light1_vol}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{50}  @tab volume of 1st light source
@item @code{light1_red}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab color of 1st light source
@item @code{light1_green}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab
@item @code{light1_blue}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab
@item @dots{}                @tab @dots{}       @tab @dots{}                                           @tab @dots{}
@item @code{light9_vol}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{100}@} @tab @code{0}   @tab volume of 9th light source
@item @code{light9_red}      @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab color of 9th light source
@item @code{light9_green}    @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab
@item @code{light9_blue}     @tab @code{int}    @tab @{@code{0}, @dots{}, @code{255}@} @tab @code{255} @tab
@end multitable


@c Clipping Variables
@c ------------------

@node Clipping Variables, Dithering Variables, Lighting Variables, List Of All Reserved Words
@section Clipping Variables

@multitable {@code{clip_front}} {@code{double}} {@code{dodecahedron, }} {@code{sphere}} {additional clip region}
@item Reserved Word     @tab Type          @tab Range @tab Def.     @tab Description
@item @code{clip}       @tab @code{int}    @tab @{@code{sphere},@*
                                                  @code{tetrahedron},@*
                                                  @code{cube},@*
                                                  @code{octahedron},@*
                                                  @code{dodecahedron},@*
                                                  @code{icosahedron},@*
                                                  @code{cylinder},@*
                                                  @code{user}, @code{none}@}            @tab @code{sphere} @tab clipping area shape
@item @code{clip_front} @tab @code{double} @tab [@code{-9999}, @code{9999}] @tab @code{10}  @tab additional clip region
@item @code{clip_back}  @tab @code{double} @tab [@code{-9999}, @code{9999}] @tab @code{-10} @tab additional clip region
@item @code{radius}     @tab @code{double} @tab ]@code{0}, @code{9999}]     @tab @code{10}  @tab radius of clip region
@item @code{center_x}   @tab @code{double} @tab [@code{-9999}, @code{9999}] @tab @code{0}   @tab center of clip region
@item @code{center_y}   @tab @code{double} @tab [@code{-9999}, @code{9999}] @tab @code{0}   @tab center of clip region
@item @code{center_z}   @tab @code{double} @tab [@code{-9999}, @code{9999}] @tab @code{0}   @tab center of clip region
@end multitable

@c Dithering Variables
@c -------------------

@node Dithering Variables, Algorithm Variables, Clipping Variables, List Of All Reserved Words
@section Dithering Variables

@multitable {@code{dithering_method}} {@code{clustered_dot_ordered_dither, }} {Default} {size of dithering tile}
@item Reserved Word           @tab Range                         @tab Default @tab Description
@item @code{dithering_method} @tab @{@code{floyd_steinberg_filter},@*
                                                      @code{jarvis_judis_ninke_filter},@*
                                                      @code{stucki_filter},@*
                                                      @code{clustered_dot_ordered_dither},@*
                                                      @code{dispersed_dot_ordered_dither},@*
                                                      @code{dot_diffusion},@*
                                                      @code{smooth_dot_diffusion}@} @tab @code{jarv..} @tab dithering method
@item @code{serpentine_raster} @tab @{@code{yes}, @code{no}@}    @tab @code{yes} @tab use of serpentine raster
@item @code{random_weights}    @tab @{@code{yes}, @code{no}@}    @tab @code{yes} @tab use of random weights
@item @code{weight}            @tab [@code{0}, @code{1}]         @tab @code{0.5} @tab amount of random weights
@item @code{barons}            @tab @{@code{one_baron},@*
                                                         @code{two_baron}@} @tab @code{two..} @tab number of barons
@item @code{pattern_size}      @tab @{@code{pattern_4x4},@*
                                                         @code{pattern_8x8},@*
                                                         @code{pattern_16x16}@} @tab @code{..8x8} @tab size of dithering tile
@item @code{enhance_edges}     @tab @{@code{yes}, @code{no}@} @tab @code{yes} @tab enhance edges of b w image
@item @code{alpha}             @tab [@code{0}, @code{1}] @tab @code{0.9} @tab filter coefficient used for enhancing the edges
@item @code{background}        @tab [@code{0}, @code{1}] @tab @code{1.0} @tab background intensity of b&w imaeg
@item @code{tone_scale_adjustment} @tab @{@code{yes}, @code{no}@} @tab @code{yes} @tab perform tone scale adjust.
@item @code{gamma}             @tab ]@code{0},
@ifnottex
oo
@end ifnottex
@tex
$\infty$
@end tex
[ @tab @code{1.3} @tab gamma-correction
@item @code{pixel_size}        @tab ]@code{50}, @code{100}] @tab @code{73} @tab correction for printers that produce too fat pixels
@end multitable

@c Algorithm Variables
@c -------------------

@node Algorithm Variables, Constants, Dithering Variables, List Of All Reserved Words
@section Algorithm Variables

@multitable {@code{root_finder}} {@code{d_chain_anderson_bjoerck, }} {@code{bezier_all_roots }} {used root finder}
@item Variable @tab Range @tab Def.     @tab Description
@item @code{root_finder} @tab @{@code{d_chain_bisection},@*
                                                   @code{d_chain_regula_falsi},@*
                                                   @code{d_chain_pegasus},@*
                                                   @code{d_chain_anderson_bjoerck},@*
                                                   @code{d_chain_newton},@*
                                                   @code{bezier_all_roots}@} @tab @code{bezier_all_roots} @tab used root finder
@item @code{epsilon}     @tab ]@code{0}, @code{1}[ @tab @code{1e-4} @tab precision of root finder
@item @code{terations}   @tab [@code{1}, @code{2000}] @tab @code{200} @tab max. number of iterations
@end multitable

@c Constants
@c ---------

@node Constants, , Algorithm Variables, List Of All Reserved Words
@section Constants

These constants all appreared before as values for some variables
(like @code{first}, @code{second}, @code{third} or @code{color_image_format}),
but since they're actually just "ordinary" constants and thus reserved words
they are listed here for the sake of completeness:

@multitable {@code{clustered_dot_ordered_dither}} {@code{string}} {Value} {@code{first}, @code{second}, @code{third}}
@item Constant           @tab Type        @tab Value    @tab Useful together with
@item @code{yes}         @tab @code{int}  @tab @code{1} @tab any boolean variable
@item @code{no}          @tab @code{int}  @tab @code{0} @tab any boolean variable
@item @code{translate}   @tab @code{int}  @tab @code{0} @tab @code{first}, @code{second}, @code{third}
@item @code{rotate}      @tab @code{int}  @tab @code{1} @tab @code{first}, @code{second}, @code{third}
@item @code{scale}       @tab @code{int}  @tab @code{2} @tab @code{first}, @code{second}, @code{third}
@item @code{parallel}    @tab @code{int}  @tab @code{0} @tab @code{perspective}
@item @code{central}     @tab @code{int}  @tab @code{1} @tab @code{perspective}
@item @code{ambient_light}     @tab @code{int} @tab @code{1} @tab @code{illumination}
@item @code{diffuse_light}     @tab @code{int} @tab @code{2} @tab @code{illumination}
@item @code{reflected_light}   @tab @code{int} @tab @code{4} @tab @code{illumination}
@item @code{transmitted_light} @tab @code{int} @tab @code{8} @tab @code{illumination}
@item @code{sphere}            @tab @code{int} @tab @code{0} @tab @code{clip}
@item @code{tetrahedron}       @tab @code{int} @tab @code{1} @tab @code{clip}
@item @code{cube}              @tab @code{int} @tab @code{2} @tab @code{clip}
@item @code{octahedron}        @tab @code{int} @tab @code{3} @tab @code{clip}
@item @code{dodecahedron}      @tab @code{int} @tab @code{4} @tab @code{clip}
@item @code{icosahedron}       @tab @code{int} @tab @code{5} @tab @code{clip}
@item @code{cylinder}          @tab @code{int} @tab @code{6} @tab @code{clip}
@item @code{user}              @tab @code{int} @tab @code{7} @tab @code{clip}
@item @code{none}              @tab @code{int} @tab @code{8} @tab @code{clip}
@item @code{floyd_steinberg_filter}       @tab @code{int} @tab @code{0} @tab @code{dithering_method}
@item @code{jarvis_judis_ninke_filter}    @tab @code{int} @tab @code{1} @tab @code{dithering_method}
@item @code{stucki_filter}                @tab @code{int} @tab @code{2} @tab @code{dithering_method}
@item @code{clustered_dot_ordered_dither} @tab @code{int} @tab @code{3} @tab @code{dithering_method}
@item @code{dispersed_dot_ordered_dither} @tab @code{int} @tab @code{4} @tab @code{dithering_method}
@item @code{dot_diffusion}                @tab @code{int} @tab @code{5} @tab @code{dithering_method}
@item @code{smooth_dot_diffusion}         @tab @code{int} @tab @code{6} @tab @code{dithering_method}
@item @code{one_baron}     @tab @code{int} @tab @code{0} @tab @code{barons}
@item @code{two_baron}     @tab @code{int} @tab @code{1} @tab @code{barons}
@item @code{pattern_4x4}   @tab @code{int} @tab @code{0} @tab @code{pattern_size}
@item @code{pattern_8x8}   @tab @code{int} @tab @code{1} @tab @code{pattern_size}
@item @code{pattern_16x16} @tab @code{int} @tab @code{2} @tab @code{pattern_size}
@item @code{auto}       @tab @code{int} @tab ? @tab @code{color_file_format},@* @code{dither_file_format}
@item @code{jpeg}       @tab @code{int} @tab ? @tab @code{color_file_format}
@item @code{ppm}        @tab @code{int} @tab ? @tab @code{color_file_format}
@item @code{png}        @tab @code{int} @tab ? @tab @code{color_file_format}
@item @code{sun}        @tab @code{int} @tab ? @tab @code{color_file_format}
@item @code{tiff}       @tab @code{int} @tab ? @tab @code{color_file_format}, @code{dither_file_format}
@item @code{xpm}        @tab @code{int} @tab ? @tab @code{color_file_format}
@item @code{eps}        @tab @code{int} @tab ? @tab @code{dither_file_format}
@item @code{pbm}        @tab @code{int} @tab ? @tab @code{dither_file_format}
@item @code{postscript} @tab @code{int} @tab ? @tab @code{dither_file_format}
@item @code{xbm}        @tab @code{int} @tab ? @tab @code{dither_file_format}
@item @code{netscape}   @tab @code{int} @tab @code{0} @tab @code{color_file_colormap}
@item @code{optimized}  @tab @code{int} @tab @code{1} @tab @code{color_file_colormap}
@item @code{truecolor}  @tab @code{int} @tab @code{2} @tab @code{color_file_colormap}
@item @code{d_chain_bisection}        @tab @code{int} @tab @code{0} @tab @code{root_finder}
@item @code{d_chain_regula_falsi}     @tab @code{int} @tab @code{1} @tab @code{root_finder}
@item @code{d_chain_pegasus}          @tab @code{int} @tab @code{2} @tab @code{root_finder}
@item @code{d_chain_anderson_bjoerck} @tab @code{int} @tab @code{3} @tab @code{root_finder}
@item @code{d_chain_newton}           @tab @code{int} @tab @code{4} @tab @code{root_finder}
@item @code{bezier_all_roots}         @tab @code{int} @tab @code{5} @tab @code{root_finder}
@end multitable

Note: Please use these constants, @emph{not} their values, wherever you
can, because then any changes to the values are automatically
incorporated to your scripts.

@bye
